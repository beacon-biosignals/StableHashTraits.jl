var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"stable_hash\nHashVersion\nStableHashTraits.transformer\nStableHashTraits.Transformer\npick_fields\nomit_fields\nStableHashTraits.TransformIdentity\nCachedHash\nStableHashTraits.UseCache\nStableHashTraits.hoist_type\nStableHashTraits.transform_type\nStableHashTraits.transform_type_value\nnameof_string\nStableHashTraits.module_nameof_string\nStableHashTraits.is_ordered\nStableHashTraits.hash_sort_by\nStableHashTraits.parent_context\nStableHashTraits.@context\nStableHashTraits.root_version\nWithTypeNames\nTablesEq\nViewsEq","category":"page"},{"location":"api/#StableHashTraits.stable_hash","page":"API","title":"StableHashTraits.stable_hash","text":"stable_hash(x, context=HashVersion{1}(); alg=sha256)\nstable_hash(x; alg=sha256, version=1)\n\nCreate a stable hash of the given objects. As long as the context remains the same, this hash is intended to remain unchanged across julia versions. The built-in context is HashVersion{N}, and if you specify a version, this is equivalent to explicitly passing HashVersion{version}. To customize how the hash is copmuted see Using Contexts.\n\nIt is best to pass an explicit version, since HashVersion{4} is the only non-deprecated version; it is much faster than 1 and more stable than 2. Furthermore, a new hash version is provided in a future release, the hash you get by passing an explicit HashVersion{N} should not change. (Note that the number in HashVersion does not necessarily match the package version of StableHashTraits).\n\nIn hash version 4, you customize how hashes are computed using transformer, and in versions 1-4 using hash_method.\n\nTo change the hash algorithm used, pass a different function to alg. It accepts any sha related function from SHA or any function of the form hash(x::AbstractArray{UInt8}, [old_hash]).\n\nThe context value gets passed as the second argument to hash_method and transformer, and as the third argument to StableHashTraits.write. Note that both hash_method and StableHashTraits.write are deprecated.\n\nSee Also\n\ntransformer\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.HashVersion","page":"API","title":"StableHashTraits.HashVersion","text":"HashVersion{V}()\n\nThe default hash_context used by stable_hash. There are currently four versions (1-4). Version 4 should be favored when at all possible. Version 1 is the default version, so as to avoid changing the hash computed by existing code.\n\nBy explicitly passing this hash version in stable_hash you ensure that hash values for these fallback methods will not change even if new hash versions are developed.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.transformer","page":"API","title":"StableHashTraits.transformer","text":"StableHashTraits.transformer(::Type{T}, [context]) where {T}\n\nReturn Transformer indicating how to modify an object of type T before hashing it. Methods with a context are called first, and if no method for that type exists there is a fallback that calls the method without a context. Users can therefore implement a method with a context object to customize transformations for that context only, or a single argument method when they wish to affect the transformation across all contexts that don't have a context specific method.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.Transformer","page":"API","title":"StableHashTraits.Transformer","text":"StableHashTraits.Transformer(fn=identity, result_method=nothing;\n                             hoist_type=StableHashTraits.hoist_type(fn))\n\nWraps the function used to transform values before they are hashed. The function is applied (fn(x)), and then its result is hashed according to the trait @something result_method StructType(fn(x)).\n\nThe flag hoist_type indicates if it is safe to hoist type hashes outside of loops. If set to true your has will be computed more quickly. However, this hoisting is only valid when the pre-transformed type is sufficient to disambiguate the hashed values that are produced downstream AND when the post-transformed types that are concrete depend only on pre-transformed types that are themselves concrete.\n\ndanger: Use `hoist_type=true` with care\nIt is easy to introduce subtle bugs that occur in rare edge cases when using hoist_type=true. Refer to Optimizing Custom Transformers for a detailed discussion and examples of when you can safely set hoist_type=true. It is better to use a pre-defined function such as pick_fields or omit_fields.\n\nSee Also\n\ntransformer\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.pick_fields","page":"API","title":"StableHashTraits.pick_fields","text":"pick_fields(x, fields::Symbol...)\npick_fields(x, fields::NTuple{<:Any, Symbol})\npick_fields(fields::Symbol...)\npick_fields(fields::NTuple{<:Any, Symbol})\n\nReturn an object including fields from the fields of x, as per getfield. Curried versions exist, which return a function for selecting the given fields.\n\nThis function differs from returning a named tuple of fields (e.g. x -> (;x.a, x.b)) in that it does not narrow the types of the returned fields. A field of type Any of x is a field of type Any in the returned value. This ensures that pickfields can be safely used with `hoisttypeof [Transformer`](@ref).\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.omit_fields","page":"API","title":"StableHashTraits.omit_fields","text":"omit_fields(x, fields::Symbol...)\nomit_fields(x, fields::NTuple{<:Any, Symbol})\nomit_fields(fields::Symbol...)\nomit_fields(fields::NTuple{<:Any, Symbol})\n\nReturn an object excluding fields from the fields of x, as per getfield. Curried versions exist, which return a function for selecting the given fields.\n\nThis function differs from returning a named tuple of fields (e.g. x -> (;x.a, x.b)) in that it does not narrow the types of the returned fields. A field of type Any of x is a field of type Any in the returned value. This ensures that pickfields can be safely used with `hoisttypeof [Transformer`](@ref).\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.TransformIdentity","page":"API","title":"StableHashTraits.TransformIdentity","text":"StableHashTraits.TransformIdentity(x)\n\nSignal that the type x should not be transformed in the usual way, but by hashing x directly. This is useful when you want to hash both x the way it would normally be hashed without a specialized method of transformer along with some metadata. Without this wrapper, returning (metadata(x), x) from the transforming function would cause an infinite regress (adding metadata(x) upon each call).\n\nExample\n\nstruct MyArray <: AbstractVector{Int}\n    data::Vector{Int}\n    meta::Dict{String, String}\nend\n# other array methods go here...\nfunction StableHashTraits.transformer(::Type{<:MyArray})\n    return Transformer(x -> (x.meta, TransformIdentity(x)); hoist_type=true)\nend\n\nIn this example we hash both some metadata about a custom array, and each of the elements of x\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.CachedHash","page":"API","title":"StableHashTraits.CachedHash","text":"CachedHash(context)\n\nEnsure that the given hash context includes a cache of hash results. By default, the cache stores the result of hashing types and large values. Calling the same cached hash context will re-use the cache, possibly improving performance. If you do not pass a CachedHash to stable_hash it sets up its own internal cache to improve performance for repeated hashes of the same type or large values seen within the call to stable_hash.\n\nFor an object to be cached you must either signal that it should be, using UseCache or it must be:\n\nlarge enough: this is to ensure that calls to retrieve a cached result do not exceed the time it takes to simply re-hash the individual bytes of an object. You can refer to the constant CACHE_OBJECT_THRESHOLD though it is not considered part of the public API and may change with future hash versions. (The threshold will not change for a given hash version, since changing it can change an object's hashed value).\nmutable: immutable objects are not supported by WeakKeyIdDict. This means that caching immutable objects can lead to memory leaks if you don't clean up the cache regularly, since they are stored in an IdDict. Note that in practice large amounts of data are usually stored in mutable structures like Array and String; though immutable objects may contain these mutable values.\n\nSee Also\n\nstable_hash\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.UseCache","page":"API","title":"StableHashTraits.UseCache","text":"StableHashTraits.UseCache(x)\n\nSignal that the hash of x should be stored in the cache.\n\nwarning: Immutable objects can leak memory\nIf x is immutable, caching will cause the object x to be held in memory until the cache is garbage collected. This is because WeakKeyIdDicts do not support immutable objects. If there is no user defined cache, the cache will be garbage collected inside the call to stable_hash. With a user defined hash and you apply UseCache to immutable objects, you will need to make sure your cache goes out of scope in a timely fashion to avoid memory leaks.\n\nSee Also\n\ntransformer\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.hoist_type","page":"API","title":"StableHashTraits.hoist_type","text":"StableHashTraits.hoist_type(fn)\n\nReturns true if it is known that fn preservess type structure ala Transformer. See Optimizing Custom Transformers for details. This is false by default for all functions but identity and module_nameof_string. You can define a method of this function for your own fn's to signal that their results can be safely optimized via hoisting the type hash outside of loops.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.transform_type","page":"API","title":"StableHashTraits.transform_type","text":"transform_type(::Type{T}, [context])\n\nThe value to hash for type T when hashing an object's type. Users of StableHashTraits can implement a method that accepts one (T) or two arguments (T and context). If no method is implemented, the fallback transform_type value uses StructType(T) to decide how to hash T; this is documented under What gets hashed? (hash version 4).\n\nAny types returned by transform_type has transform_type applied to it, so make sure that you only return types when they are are some nested component of your type (do not return T!!)\n\nThis method is used to add additional data to the hash of a type. Internally, the data listed below is always added, outside of the call to transform_type:\n\nfieldtypes(T) of any StructType.DataType (e.g. StructType.Struct)\neltype(T) of any StructType.ArrayType or StructType.DictType or AbstractRange\n\nThese components of the type need not be returned by transform_type and you cannot prevent them from being included in a type's hash, since otherwise the assumptions necessary for efficient hash computation would be violated.\n\nExamples\n\nSingleton Types\n\nYou can opt in to hashing novel singleton types by overwriting transform_type:\n\nstruct MySingleton end\nStructTypes.StructType(::MySingleton) = StructTypes.SingletonType()\nfunction StableHashTraits.transform_type(::Type{<:MySingleton})\n    return \"MySingleton\"\nend\n\nIf you do not own the type you wish to customize, you can use a context:\n\nusing AnotherPackage: PackageSingleton\nStableHashTriats.@context HashAnotherSingleton\nfunction StableHashTraits.transform_type(::Type{<:PackageSingleton}, ::HashAnotherSingleton)\n    return \"AnotherPackage.PackageSingleton\"\nend\ncontext = HashAnotherSingleton(HashVersion{4}())\nstable_hash([PackageSingleton(), 1, 2], context) # will not error\n\nFunctions\n\nOverwriting transform_type can be used to opt-in to hashing functions.\n\nf(x) = x+1\nStableHashTraits.transform_type(::typeof(fn)) = \"Main.fn\"\n\nType Parameters\n\nTo include additional type parameters in a type's hash, you can overwrite transform_type\n\nstruct MyStruct{T,K}\n    wrapped::T\nend\n\nfunction StableHashTraits.transform_type(::Type{<:MyStruct{T,K}})\n    return \"MyStruct\", K\nend\n\nBy adding this method for type_structure both K and T will impact the hash, T because it is included in fieldtypes(<:MyStruct) and K because it is included in type_structure(<:MyStruct).\n\nIf you do not own the type you want to customize, you can specialize type_structure using a specific hash context.\n\nusing Intervals\n\nStableHashTraits.@context IntervalEndpointsMatter\n\nfunction HashTraits.type_structure(::Type{<:I}, ::IntervalEndpointsMatter) where {T, L, R, I<:Interval{T, L, R}}\n    return (L, R)\nend\n\ncontext = IntervalEndpointsMatter(HashVersion{4}())\nstable_hash(Interval{Closed, Open}(1, 2), context) !=\n    stable_hash(Interval{Open, Closed}(1, 2), context) # true\n\nSee Also\n\ntransformer @context\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.transform_type_value","page":"API","title":"StableHashTraits.transform_type_value","text":"transform_type_value(::Type{T}, [trait], [context]) where {T}\n\nThe value that is hashed for type T when hashing a type as a value (e.g. stable_hash(Int)). Hashing types as values is an error by default, but you can use this method to opt-in to hashing a type as a value. You can return types (e.g. type parameters of T), but do not return T or you will get a stack overflow.\n\nExample\n\nYou can define a method of this function to opt in to hashing your type as a value.\n\nstruct MyType end\nStableHashTraits.transform_type_value(::Type{T}) where {T<:MyType} = module_nameof_string(T)\nstable_hash(MyType) # does not error\n\nLikewise, you can opt in to this behavior for a type you don't own by defining a context.\n\nStableHashTraits.@context HashNumberTypes\nfunction StableHashTraits.type_value_identifier(::Type{T},\n                                                ::HashNumberTypes) where {T <: Number}\n    return module_nameof_string(T)\nend\nstable_hash(Int, HashNumberTypes(HashVersion{4}())) # does not error\n\nSee Also\n\ntransformer StableHashTraits.transform_type\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.nameof_string","page":"API","title":"StableHashTraits.nameof_string","text":"nameof_string(::Type{T})\nnameof_string(T::Module)\nnameof_string(::T) where {T}\n\nGet a stable name of T. This is a helpful utility for writing your own methods of StableHashTraits.transform_type and StableHashTraits.transform_type_value. The stable name is computed from nameof. Anonymous names (e.g. module_nameof_string(x -> x+1)) throw an error, as no stable name is possible in this case.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.module_nameof_string","page":"API","title":"StableHashTraits.module_nameof_string","text":"module_nameof_string(::Type{T})\nmodule_nameof_string(T::Module)\nmodule_nameof_string(::T) where {T}\n\nGet a (mostly!) stable name of T. This is a helpful utility for writing your own methods of StableHashTraits.transform_type and StableHashTraits.transform_type_value. The stable name includes the name of the module that T was defined in. Any uses of Core are replaced with Base to keep the name stable across versions of julia. Anonymous names (e.g. module_nameof_string(x -> x+1)) throw an error, as no stable name is possible in this case.\n\ndanger: A type's module often changes\nThe module of many types are considered an implementation detail and can change between non-breaking versions of a package. For this reason uses of module_nameof_string must be explicitly specified by user of StableHashTraits. This function is not used internally hor HashVersion{4} for types that are not defined in StableHashTraits.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.is_ordered","page":"API","title":"StableHashTraits.is_ordered","text":"is_ordered(x)\n\nIndicates whether the order of the elements of object x are important to its hashed value. If false, x's elements will first be collected and sort'ed before hashing them. When calling sort, hash_sort_by is passed as the by keyword argument. If x is a DictType, the elements are sorted by their keys rather than their elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.hash_sort_by","page":"API","title":"StableHashTraits.hash_sort_by","text":"`hash_sort_by(x)`\n\nDefines how the elements of a hashed container x are sorted if is_ordered of x returns false. The return value of this function is passed to sort as the by keyword.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.parent_context","page":"API","title":"StableHashTraits.parent_context","text":"StableHashTraits.parent_context(context)\n\nReturn the parent context of the given context object. (See hash_method and StableHashTraits.@context for details of using context). The default method falls back to returning HashVersion{1}, but this is flagged as a deprecation warning; in the future it is expected that all contexts define this method.\n\nThis is normally all that you need to know to implement a new context. However, if your context is expected to be the root context—one that does not fallback to any parent (akin to HashVersion)—then there may be a bit more work involved. In this case, parent_context should return nothing. You will also need to define StableHashTraits.root_version.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.@context","page":"API","title":"StableHashTraits.@context","text":"StableHashTraits.@context MyContext\n\nShorthand for declaring a hash context.\n\nContexts are used to customize the behavior of a hash for a type you don't own, by passing the context as the second argument to stable_hash, and specializing methods of transformer or StableHashTraits.transform_type on your context (see example below).\n\nThe clause @context MyContext is re-written to:\n\nstruct MyContext{T}\n    parent::T\nend\nStableHashTraits.parent_context(x::MyContext) = x.parent\n\nThe parent context is typically another custom context, or the root context HashVersion{4}().\n\nExample\n\nStableHashTraits.@context NumberAbs\ntransformer(::Type{<:Number}, ::NumberAbs) = Transformer(abs; hoist_type=true)\nstable_hash(10, NumberAbs(HashVersion{4}())) == stable_hash(-10, NumberAbs(HashVersion{4}()))\n\nSee Also\n\nparent_context\n\n\n\n\n\n","category":"macro"},{"location":"api/#StableHashTraits.root_version","page":"API","title":"StableHashTraits.root_version","text":"StableHashTraits.root_version(context)\n\nReturn the version of the root context: an integer in the range (1, 2). The default fallback method value returns 1.\n\nIn almost all cases, a root hash context should return 2. The optimizations used in HashVersion{2} include a number of changes to the hash-trait implementations that do not alter the documented behavior but do change the actual hash value returned because of how and when elements get hashed.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.WithTypeNames","page":"API","title":"StableHashTraits.WithTypeNames","text":"WithTypeNames(parent_context)\n\nIn this hash context, StableHashTraits.transform_type returns module_nameof_string for all types, in contrast to the default behavior (which mostly uses nameof_string(StructType(T))).\n\nwarn: Unstable\nmodule_nameof_string's return value can change with non-breaking changes if e.g. the module of a function or type is changed because it's considered an implementation detail of a package.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.TablesEq","page":"API","title":"StableHashTraits.TablesEq","text":"TablesEq(parent_context)\n\nIn this hash context the type and structure of a table do not impact the hash that is created, only the set of columns (as determined by Tables.columns), and the hash of the individual columns matter.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.ViewsEq","page":"API","title":"StableHashTraits.ViewsEq","text":"ViewsEq(parent_context)\n\nCreate a hash context where only the contents of an array or string determine its hash: that is, the type of the array or string (e.g. SubString vs. String) does not impact the hash value.\n\nwarn: Deprecated\nIn HashVersion{4} this is already true, so there is no need for ViewsEq. This does not change the behavior of HashVersion{4} or later.\n\n\n\n\n\n","category":"type"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"Deprecated API:","category":"page"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"StableHashTraits.hash_method\nstable_typename_id\nstable_type_id\nStableHashTraits.write\nHashAndContext","category":"page"},{"location":"deprecated/#StableHashTraits.hash_method","page":"Deprecated","title":"StableHashTraits.hash_method","text":"StableHashTraits.hash_method(x, [context])\n\nRetrieve the trait object that indicates how a type should be hashed using stable_hash. You should return one of the following values.\n\nWriteHash(): writes the object to a binary format using StableHashTraits.write(io, x)  and takes a hash of that. StableHashTraits.write(io, x) falls back to Base.write(io,  x) if no specialized methods are defined for x.\nIterateHash(): assumes the object is iterable and finds a hash of all elements\nStructHash([pair = (fieldnames ∘ typeof) => getfield], [order]): hash the structure of  the object as defined by a sequence of pairs. How precisely this occurs is determined by  the two arguments:\npair Defines how fields are extracted; the default is fieldnames ∘ typeof => getfield but this could be changed to e.g. propertynames => getproperty or Tables.columnnames => Tables.getcolumn. The first element of the pair is a function used to compute a list of keys and the second element is a two argument function used to extract the keys from the object.\norder can be :ByOrder (the default)—which sorts by the order returned by pair[1]—or :ByName—which sorts by lexigraphical order.\nFnHash(fn, [method]): hash the result of applying fn to the given object. Optionally, use method to hash the result of fn, otherwise calls hash_method on the result to determine how to hash it. There are two built-in functions commonly used with FnHash.\nstable_typename_id: Get the qualified name of an object's type, e.g. Base.String and return 64 bit hash of this string\nstable_type_id: Get the qualified name and type parameters of a type, e.g.  Base.Vector{Int}, and return a 64 bit hash of this string.\n@ConstantHash(x): at compile time, hash the literal (constant) string or number using  sha256 and include the first 64 bits as a constant number that is recursively hashed  using the WriteHash method.\nTuple: apply multiple methods to hash the object, and then recursively hash their  results. For example: (@ConstantHash(\"header\"), StructHash()) would compute a hash for  both the string \"header\" and the fields of the object, and then recursively hash these  two hashes.\n\nYour hash will be stable if the output for the given method remains the same: e.g. if write is the same for an object that uses WriteHash, its hash will be the same; if the fields are the same for StructHash, the hash will be the same; etc...\n\nMissing from the above list is one final, advanced, trait: HashAndContext which can be used to change the context within the scope of a given object.\n\nCustomizing hash computations with contexts\n\nYou can customize how hashes are computed within a given scope using a context object. This is also a very useful way to avoid type piracy. The context can be any object you'd like and is passed as the second argument to stable_hash. By default it is equal to HashVersion{1}() and this determines how objects are hashed when a more specific method is not defined.\n\nThis context is then passed to both hash_method and StableHashTraits.write (the latter is the method called for WriteHash, and falls back to Base.write). Because of the way the root contexts (HashVersion{1} and HashVersion{2}) are defined, you normally don't have to include this context as an argument when you define a method of hash_context or write because there are appropriate fallback methods.\n\nWhen you define a hash context it should normally accept a parent context that serves as a fallback, and return it in an implementation of the method StableHashTraits.parent_context.\n\nAs an example, here is how we could write a context that treats all named tuples with the same keys and values as equivalent.\n\nstruct NamedTuplesEq{T}\n    parent::T\nend\nStableHashTraits.parent_context(x::NamedTuplesEq) = x.parent\nfunction StableHashTraits.hash_method(::NamedTuple, ::NamedTuplesEq)\n    return FnHash(stable_typename_id), StructHash(:ByName)\nend\ncontext = NamedTuplesEq(HashVersion{2}())\nstable_hash((; a=1:2, b=1:2), context) == stable_hash((; b=1:2, a=1:2), context) # true\n\nIf we instead defined parent_context to return nothing, our context would need to implement a hash_method that covered the types AbstractRange, Int64, Symbol and Pair for the call to stable_hash above to succeed.\n\nCustomizing hashes within an object\n\nContexts can be customized not only when you call stable_hash but also when you hash the contents of a particular object. This lets you change how hashing occurs within the object. See the docstring of HashAndContext for details.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/#StableHashTraits.stable_typename_id","page":"Deprecated","title":"StableHashTraits.stable_typename_id","text":"stable_typename_id(x)\n\nReturns a 64 bit hash that is the same for a given type so long as the name and the module of the type doesn't change.\n\nExample\n\njulia> stable_typename_id([1, 2, 3])\n0x56c6b9ca080a0aa4\n\njulia> stable_typename_id([\"a\", \"b\"])\n0x56c6b9ca080a0aa4\n\nnote: Note\nIf the module of a type is Core it is renamed to Base before hashing because the location of some types changes between Core to Base across julia versions. Likewise, the type names of AbstractArray types are made uniform as their printing changes from Julia 1.6 -> 1.7.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/#StableHashTraits.stable_type_id","page":"Deprecated","title":"StableHashTraits.stable_type_id","text":"stable_type_id(x)\n\nReturns a 64 bit hash that is the same for a given type so long as the module, and string representation of a type is the same (invariant to comma spacing).\n\nExample\n\njulia> stable_type_id([1, 2, 3])\n0xfd5878e59e259648\n\njulia> stable_type_id([\"a\", \"b\"])\n0xe191f67c4c8e3370\n\nnote: Note\nIf the module of a type is Core it is renamed to Base before hashing because the location of some types changes between Core to Base across julia versions. Likewise, the type names of AbstractArray types are made uniform as their printing changes from Julia 1.6 -> 1.7.\n\nwarn: Warn\nThis function has a known bug that has been left in to avoid breaking old hashes. (The long-term plan is to eliminate this and qualified_type from the API, see https://github.com/beacon-biosignals/StableHashTraits.jl/pull/55 for details). The bug means that the type has can depend on the order in which you load modules and call stable_type_id. To make use of the version of this function that has been fixed you can call stable_type_id_fixed\n\n\n\n\n\n","category":"function"},{"location":"deprecated/#StableHashTraits.write","page":"Deprecated","title":"StableHashTraits.write","text":"StableHashTraits.write(io, x, [context])\n\nWrites contents of x to an io buffer to be hashed during a call to stable_hash. Fall back methods are defined as follows:\n\nwrite(io, x, context) = write(io, x)\nwrite(io, x) = Base.write(io, x)\n\nUsers of StableHashTraits can overwrite either the 2 or 3 argument version for their types to customize the behavior of stable_hash.\n\nSee also: StableHashTraits.hash_method.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/#StableHashTraits.HashAndContext","page":"Deprecated","title":"StableHashTraits.HashAndContext","text":"HashAndContext(method, old_context -> new_context)\n\nA special hash method that changes the context when hashing the contents of an object. The method defines how the object itself should be hashed and the second argument is a callable which transforms the old context to the new.\n\nFor example, here is how we can make sure the arrays in a specific object have a hash that is invariant to endianness without having to copy the array.\n\nstruct EndianInvariant{P}\n    parent_context::P\nend\nStableHashTraits.parent_context(x::EndianInvariant) = x.parent_context\n\nstruct CrossPlatformData\n    data::Vector{Int}\nend\n\nStableHashTraits.hash_method(::Number, ::EndianInvariant) = FnHash(htol, WriteHash())\nStableHashTraits.hash_method(::CrossPlatformData) = HashAndContext(IterateHash(), EndianInvariant)\n\nNote that we could accomplish this same behavior using FnHash(x -> htol.(x.data)), but it would require copying that data to do so.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Internal-Methods","page":"Internal Functions","title":"Internal Methods","text":"","category":"section"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"Documented methods that are not part of the public API.","category":"page"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"StableHashTraits.hash_type\nStableHashTraits.HashState\nStableHashTraits.similar_hash_state\nStableHashTraits.start_nested_hash!\nStableHashTraits.end_nested_hash!\nStableHashTraits.update_hash!\nStableHashTraits.compute_hash!\nStableHashTraits.cache_hash_type!\nStableHashTraits.cache_hash_value!","category":"page"},{"location":"internal/#StableHashTraits.hash_type","page":"Internal Functions","title":"StableHashTraits.hash_type","text":"hash_type(hash_state, context, T)\n\nGet the hash of type T in the given context.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.HashState","page":"Internal Functions","title":"StableHashTraits.HashState","text":"HashState(alg, context)\n\nGiven a function that implements the hash algorithm to use and the current hash context, setup the necessary state to track updates to hashing as we traverse an object's structure and return it.\n\n\n\n\n\n","category":"type"},{"location":"internal/#StableHashTraits.similar_hash_state","page":"Internal Functions","title":"StableHashTraits.similar_hash_state","text":"similar_hash_state(state::HashState)\n\nAkin to similar for arrays, this constructs a new object of the same concrete type as state\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.start_nested_hash!","page":"Internal Functions","title":"StableHashTraits.start_nested_hash!","text":"start_nested_hash!(state::HashState)\n\nReturn an updated state that delimits hashing of a nested structure; calls made to update_hash! after startnestedhash! will be handled as nested elements up until end_nested_hash! is called.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.end_nested_hash!","page":"Internal Functions","title":"StableHashTraits.end_nested_hash!","text":"end_nested_hash!(state::HashState)\n\nReturn an updated state that delimints the end of a nested structure.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.update_hash!","page":"Internal Functions","title":"StableHashTraits.update_hash!","text":"update_hash!(state::HashState, bytes)\n\nReturns the updated hash state given a set of bytes (either a tuple or array of UInt8 values).\n\nupdate_hash!(state::HashState, obj, context)\n\nReturns the updated hash, given an object and some context. The object will be written to some bytes using StableHashTraits.write(io, obj, context).\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.compute_hash!","page":"Internal Functions","title":"StableHashTraits.compute_hash!","text":"compute_hash!(state::HashState)\n\nReturn the final hash value to return for state\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.cache_hash_type!","page":"Internal Functions","title":"StableHashTraits.cache_hash_type!","text":"cache_hash_type!(hash_state, context, T)\n\nHash type T in the given context to hash_state. The result is cached and future calls to cache_hash_type! will hash the cached result.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.cache_hash_value!","page":"Internal Functions","title":"StableHashTraits.cache_hash_value!","text":"cache_hash_value!(x, hash_state, context, trait)\n\nHash the value of object x to the hash_state for the given context and hash trait. Caches types, larger values and those objects manually flagged to be cached.\n\n\n\n\n\n","category":"function"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"Deprecated, non-public API methods; these will be deleted when the deprecated functionality is removed.","category":"page"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"StableHashTraits.stable_typefields_id","category":"page"},{"location":"internal/#StableHashTraits.stable_typefields_id","page":"Internal Functions","title":"StableHashTraits.stable_typefields_id","text":"stable_typefields_id(x)\n\nReturns a 64 bit hash that is the same for a given type so long as the set of field names remains unchanged.\n\n\n\n\n\n","category":"function"},{"location":"#StableHashTraits","page":"Manual","title":"StableHashTraits","text":"","category":"section"},{"location":"#Use-Case-and-Design-Rationale","page":"Manual","title":"Use Case and Design Rationale","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"StableHashTraits is designed to be used in cases where there is an object you wish to serialize in a content-addressed cache. How and when objects pass the same input to a hashing algorithm is meant to be predictable and well defined, so that the user can reliably define methods of transformer to modify this behavior.","category":"page"},{"location":"#What-gets-hashed?-(hash-version-4)","page":"Manual","title":"What gets hashed? (hash version 4)","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"This covers the behavior when using the latest hash version (4). You can read the documentation for hash version 1 here and hash version 2-3 here.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"When you call stable_hash(x; version=4), StableHashTraits hashes both the value x and its type T. Rather than hashing the type T itself directly, in most cases instead SructTypes.StructType(T) is hashed, using SructTypes.jl. For example, since the \"StructType\" of Float64 and Float32 are both NumberType, when hashing Float64 and Float32 values, value and NumberType are hashed. This provides a simple trait-based system that doesn't need to rely on internal details. See below for more details.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"You can customize how the value is hashed using StableHashTraits.transformer, and how its type is hashed using StableHashTraits.transform_type. If you need to customize either of these functions for a type that you don't own, you can use a @context to avoid type piracy.","category":"page"},{"location":"#StructType.DataType","page":"Manual","title":"StructType.DataType","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"StructType.DataType denotes a type that is some kind of \"record\"; i.e. its content is defined by the fields (getfield(f) for f in fieldnames(T)) of the type. Since it is the default, it is used to hash most types.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the value, each field value (getfield(f) for f in fieldnames(T)) is hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If StructType(T) <: StructTypes.UnorderedStruct (the default), the field values are first sorted by the lexographic order of the field names.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The type of a data type is hashed using string(nameof(T)), the fieldnames(T), (sorting them for UnorderedStruct), along with a hash of the type of each element of fieldtypes(T) according to their StructType.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"No type parameters are hashed by default. To hash these you need to specialize on StableHashTraits.transform_type for your struct. Note that because fieldtypes(T) is hashed, you don't need to do this unless your type parameters are not used in the specification of your field types.","category":"page"},{"location":"#StructType.ArrayType","page":"Manual","title":"StructType.ArrayType","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"ArrayType is used when hashing a sequence of values.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the value, each element of an array type is hashed using iterate. If the object isa AbstractArray, the size(x) of the object is also hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If StableHashTraits.is_ordered returns false the elements are first sorted according to StableHashTraits.hash_sort_by.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the type, the string \"StructTypes.ArrayType\" is hashed (meaning that the kind of array won't matter to the hash value), and the type of the elype is hashed, according to its StructType. If the type <: AbstractArray, the ndims(T) is hashed.","category":"page"},{"location":"#StructTypes.DictType","page":"Manual","title":"StructTypes.DictType","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"To hash the value, each key-value pair of a dict type is hashed, as returned by StructType.keyvaluepairs(x).","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If StableHashTraits.is_ordered returns false (which is the default return value) the pairs are first sorted according their keys using StableHashTraits.hash_sort_by.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the type, the string \"StructTypes.DictType\" is hashed (meaning that the kind of dictionary won't matter), and the type of the keytype and valtype is hashed, according to its StructType.","category":"page"},{"location":"#AbstractRange","page":"Manual","title":"AbstractRange","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"AbstractRange constitutes an exception to the rule that we use StructType: for efficient hashing, ranges are treated as another first-class container object, separate from array types.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The value is hashed as (first(x), step(x), last(x)).","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The type is hashed as \"Base.AbstractRange\" along with the type of the eltype, according to its StructType. Thus, the type of range doesn't matter (just that it is a range).","category":"page"},{"location":"#StructTypes{Number/String/Bool}Type","page":"Manual","title":"StructTypes{Number/String/Bool}Type","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"To hash the value, the result of Base.writeing the object is hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the type, the value of string(\"StructType.\", nameof_string(StructType(T)))) is used (c.f. StableHashTraits.nameof_string for details). Note that this means the type of the value itself is not being hashed, rather a string related to its struct type.","category":"page"},{"location":"#StructType.CustomStruct","page":"Manual","title":"StructType.CustomStruct","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"For any StructType.CustomStruct, the object is first StructType.lowered and the result is hashed according to the lowered StructType.","category":"page"},{"location":"#missing-and-nothing","page":"Manual","title":"missing and nothing","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"There is no value hashed for missing or nothing; the type is hashed as the string \"Base.Missing\" and \"Base.Nothing\" respectively. Note in particular the string \"Base.Missing\" does not have the same hash as missing, since the former would have its struct type hashed.","category":"page"},{"location":"#StructType.{Null/Singleton}Type","page":"Manual","title":"StructType.{Null/Singleton}Type","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Null and Singleton types are hashed solely according to their type (no value is hashed)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Their types is hashed by StableHashTraits.nameof_string This means the module of the type does not matter: the module of a type is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a type.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"[!NOTE] If you wish to disambiguate functions or types that have the same name but that come from different modules you can overload StableHashTraits.transform_type for those functions. If you want to include the module name for a broad set of types, rather than explicitly specifying a module name for each type, you may want to consider calling StableHashTraits.module_nameof_string in the body of your transform_type method. This can avoid a number of footguns when including the module names: for example, module_nameof_string renames Core to Base to elide Base julia changes to the location of a functions between these two modules and it renames pluto workspace modules to prevent structs from having a different hash each time the notebook is run.","category":"page"},{"location":"#Function","page":"Manual","title":"Function","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Function values are hashed according to their their fields (getfield(f) for f in fieldnames(f)) as per StructType.UnorderedStruct; functions can have fields when they are curried (e.g. ==(2)), and so, for this reason, the fields are included in the hash by default.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The type of the function is hashed according to its StableHashTraits.nameof_string, therefore excluding its module. The exact module of a function is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a function.","category":"page"},{"location":"#Type","page":"Manual","title":"Type","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"When hashing a type as a value (e.g. stable_hash(Int; version=4)) the value of `StableHashTraits.nameof_string is hashed. The exact module of a type is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a type.","category":"page"},{"location":"#Examples","page":"Manual","title":"Examples","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"All of the following hash examples follow directly from the definitions above, but may not be so obvious to the reader.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Most of the behaviors described below can be customized/changed by using your own hash StableHashTraits.@context, which can be passed as the second argument to stable_hash. StableHashTraits tries to defer to StructTypes for most defaults instead of making more opinionated choices.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The order of NamedTuple pairs does not matter, because NamedTuple has a struct type of UnorderedStruct:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash((;a=1,b=2); version=4) == stable_hash((;b=2,a=1); version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Two structs with the same fields and name hash equivalently, because the default struct type is UnorderedStruct:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"module A\n    struct X\n        bar::Int\n        foo::Float64\n    end\nend\n\nmodule B\n    struct X\n        foo::Float64\n        bar::Int\n    end\nend\n\nstable_hash(B.X(2, 1); version=4) == stable_hash(A.X(1, 2); version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Different array types with the same content hash to the same value:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash(view([1,2,3], 1:2); version=4) == stable_hash([1,2]; version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Byte-equivalent arrays of all NumberType values will hash to the same value:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash([0.0, 0.0]; version=4) == stable_hash([0, 0]; version=4)\nstable_hash([0.0f0, 0.0f0]; version=4) != stable_hash([0, 0]; version=4) # not byte equivalent","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Also, even though the bytes are the same, since the size is hashed, we have:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash([0.0f0, 0.0f0]; version=4) != stable_hash([0]; version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If the eltype has a different StructType, no collision will occur:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash(Any[0.0, 0.0]; version=4) != stable_hash([0, 0]; version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Even if the mathematical values are the same, if the bytes are not the same no collision will occur:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash([1.0, 2.0]; version=4) != stable_hash([1, 2]; version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Two types with the same name but different type parameters will hash the same (unless you define a transform_type_value method for your type to include those type parameters in its return value):","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"struct MyType{T} end\nstable_hash(MyType{:a}) == stable_hash(MyType{:b}) # true","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Numerical changes will, of course, change the hash. One way this can catch you off guard are some differences in StaticArray outputs between julia versions:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> using StaticArrays, StableHashTraits;\n\njulia> begin\n        rotmatrix2d(a) = @SMatrix [cos(a) sin(a); -sin(a) cos(a)]\n        rotate(a, p) = rotmatrix2d(a) * p\n        rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n    end;","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In julia 1.9.4:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"\njulia> bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=4))\n\"4ccdc172688dd2b5cd50ba81071a19217c3efe2e3b625e571542004c8f96c797\"\n\njulia> rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n2-element SVector{2, Float64} with indices SOneTo(2):\n  7.419375817039376e-17\n -0.5953242152248626","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In julia 1.6.7","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=4))\n\"3b8d998f3106c05f8b74ee710267775d0d0ce0e6780c1256f4926d3b7dcddf9e\"\n\njulia> rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n2-element SVector{2, Float64} with indices SOneTo(2):\n  5.551115123125783e-17\n -0.5953242152248626","category":"page"},{"location":"#Basic-Customization","page":"Manual","title":"Basic Customization","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"To customize hashing, you typically want to simply override a method of StableHashTraits.transformer. This should return a function wrapped in a StableHashTraits.Transformer object that will be applied to an object and its result is the actual value that gets hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"using StableHashTraits\nusing StableHashTraits: Transformer\nusing Dates\n\nstruct MyType\n   data::Vector{UInt8}\n   metadata::Dict{Symbol, Any}\nend\n# ignore `metadata`, `data` will be hashed using fallbacks for `AbstractArray` type\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(pick_fields(:data))\n# NOTE: `pick_fields` is a helper function implemented by `StableHashTraits`\n# it creates a named tuple with the given object fields; in the above code it is used\n# in its curried form e.g. `pick_fields(:data)` is the same as `x -> pick_fields(x, :data)`\na = MyType(read(\"myfile.txt\"), Dict{Symbol, Any}(:read => Dates.now()))\nb = MyType(read(\"myfile.txt\"), Dict{Symbol, Any}(:read => Dates.now()))\nstable_hash(a; version=4) == stable_hash(b; version=4) # true","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"!!! note \"Use pick_fields and omit_fields     It is recommended you use pick_fields or omit_fields when you simply want to select some subset of fields to be hashed, as they allow for more optimized hashes than directly returning a named tuple of a field subset.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"StableHashTraits.Transformer takes a second positional argument which is the StructType you wish to use on the transformed return value. By default StructType is applied to the result to determine this automatically, but in some cases it can be useful to modify this trait by passing a second argument.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"tip: Avoid StackOverflow using `TransformIdentity`\nMake sure you don't return the object itself as an element of some collection. It can be tempting to do e.g. (mymetadata(x), x) as a return value for transformer's function. Instead you can use StableHashTraits.TransformIdentity to make sure this won't lead to an infinite regress: e.g. (mymetadata(x), TransformIdentity(x)). Using StableHashTraits.TransformIdentity will cause x's transformed result to be x itself, thereby avoiding the infinite regress.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"transformer customizes how the content of your object is hashed. The hash of the type is customized separately using StableHashTraits.transform_type.","category":"page"},{"location":"#Using-Contexts","page":"Manual","title":"Using Contexts","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Because not every package knows about either StableHashTraits or StructTypes, there may be types you don't own that you want to customize the hash of. In this scenario you should define a context object that you pass as the second argument to stable_hash and define a method of transformer that dispatches on this context object as its second argument.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"A context is simply an arbitrary object that defines a method for StableHashTraits.parent_context. By default the context to stable_hash is HashVersion{version}(). Because of parent_context, contexts can be stacked, and a HashVersion should be at the bottom of the stack. There are fallback methods for transformer that look at the value implemented by the parent context. In this way you need only define methods for the types you want to customize.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"For example, this customization makes the ordering of named tuple keys affect the hash value.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> begin\n        struct NamedTuplesOrdered{T}\n            parent::T\n        end\n        StableHashTraits.parent_context(x::NamedTuplesOrdered) = x.parent\n        function transformer(::Type{<:NamedTuple}, ::NamedTuplesOrdered)\n            Transformer(identity, StructTypes.OrderedStruct())\n        end\n        context = NamedTuplesOrdered(HashVersion{4}())\n       end;\n\njulia> stable_hash((; a=1:2, b=1:2), context) != stable_hash((; b=1:2, a=1:2), context)\ntrue","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Without this context, the keys are first sorted because StructType(NamedTuple) isa StructType.UnorderedStruct.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"As a short hand you can use StableHashTraits.@context for creating simple contexts, like the one above. Like so:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> begin\n        @context NamedTuplesOrdered\n        function transformer(::Type{<:NamedTuple}, ::NamedTuplesOrdered)\n            Transformer(identity, StructTypes.OrderedStruct())\n        end\n        context = NamedTuplesOrdered(HashVersion{4}())\n       end;\n\njulia> stable_hash((; a=1:2, b=1:2), context) != stable_hash((; b=1:2, a=1:2), context)\ntrue","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"There are several useful, predefined contexts available in StableHashTraits that can be used to change how hashing works:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"WithTypeNames\nTablesEq","category":"page"},{"location":"#Caching","page":"Manual","title":"Caching","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"StableHashTraits caches hash results for all types and large values. This cache is initialized per call to stable_hash; to leverage the same cache over multiple calls you can create a CachedHash,","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"context = CachedHash(HashVersion{3}())\nstable_hash(x, context)\nstable_hash(y, context) # previously cached values will be re-used","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"However, if you change or add any method definitions that are used to customize hashes (e.g. StableHashTraits.transformer) you will need to create a new context to avoid using stale hash values.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If you know that a particular object will be hashed repeatedly, you can make sure that it is cached by wrapping it in a StableHashTraits.UseCache object during a call to StableHashTraits.transformer.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"using StableHashTraits\nusing StableHashTraits: Transformer, UseCache\n\nstruct Foo\n    x::Int\n    ref::Bar\nend\n\nstruct Bar\n    data::Vector{Int}\nend\n\nfoos = Foo.(rand(Int, 10_000), Ref(Bar(rand(Int, 1_000)))) # NOTE: if `Bar` were larger its data would be automatically cached\n# do not repeatedly hash `Bar`:\ntransformer(::Type{<:Bar}) = Transformer(UseCache)","category":"page"},{"location":"#Optimizing-Custom-Transformers","page":"Manual","title":"Optimizing Custom Transformers","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"By default, stable hash traits follows a safe, but slower code path for arbitrary functions passed to Transformer. However, in some cases it can use a faster code path, given that some assumptions about the types returned by the transforming function are maintained. The identity function and the functions returned by pick_fields and omit_fields use this faster code path by default.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In particular, a keyword argument to Transformer, hoist_type can be set to true to use this faster code path. Functions that implement StableHashTraits.hoist_type(::typeof(fn)) can return true to signal that they are safe when using this faster code path. This function is called to determine the default value of hoist_type when this function is passed as the first argument to Transformer.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The exact criteria for when this code path is unsafe are somewhat subtle, and will be described below, along with some examples. However, you can always safely use hoist_type=true either when the function always returns the same type (e.g. it transforms all inputs into String values) OR when the following three criteria are met:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The type that transformer dispatches on is concrete.\nThe type that transformer dispatches on contains no abstract types: that is, for any contained array type or dict types, their eltypes are concrete and for any contained data type, its fieldtypes are concrete.\nThe function you pass to Transformer is type stable","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"When set to true, hoist_type=true hashes the type of the pre-transformed object, prior to looping over the contents of the post-transformed object: its fields (for a data type) or the elements (for an array or dict type). Once the contents of the object are being looped over, hashing the type of each concrete-typed element or field is skipped. For example, when hashing an Array{Int} the Int will only be hashed once, not once for every element.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"When hoist_type=false (the default for most functions) the type of the return value from transformer is hashed alongside the transformed value. This can be a lot slower, but ensures the that no unexpected hash collisions will occur.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"More precisely, this hoisting is only valid when one of these two criteria are satisfied:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"the pre-transformed type is sufficient to disambiguate the hash of the downstream object values absent their object types.\nthe post-transformed types do not change unless the caller inferred type of the input it depends on changes","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The latter criteria is more stringent than type stability. A function input could have a caller-inferred type of Any, be type stable, and return either Char or an Int depending on the value of its input. Such a function would violate this second criteria.","category":"page"},{"location":"#Examples-2","page":"Manual","title":"Examples","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"When is the pre-transformed type sufficient to disambiguate hashed values? First, many type-unstable functions should be considered unable to meet this criteria. The only time they are certain to be safe is when the values disambiguate the hash regardless of the type.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"For instance, the assmuptions of hoist_type=true would be violated by the function x -> x < 0 : Char(0) ? Int32(0) because the bits that are hashed downstream are identical, even though the type information that should be hashed with them are different: Char is a StringType and Ing32 is a NumberType.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In contrast, x -> x < 0 : Char(1) : Int32(2) is safe to use with hoist_type=true, because although the type changes, the byte sequence of the value never overlaps, regardless of the type returned. If you are confident the bit sequence will be unique in this way, you could safely use hoist_type=true even though the transformer is type unstable.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Beware! When a type unstable function will be unsafe for a given type depends on the context, because users can define their own type_transform that can lead to more type details being important to the hashed value. For instance, in the default context x -> x < 0 : Int32(0) ? UInt32(0) would be considered safe, since both Int32 and UInt32 have the same type for purposes of hashing (NumberType), but if the user were to write a custom transform_type in a HashExactNumberType context, now this function is no longer safe to use with hoist_type=true.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"These examples hopefully help to clarify when type-unstable functions can lead to unexpected hash collisions with hoist_type=true. However type stable functions can also lead to invalid hashes with hoist_type=true. For example:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"struct MyType\n    a::Any\nend\n# ignore `metadata`, `data` will be hashed using fallbacks for `AbstractArray` type\n# DO NOT DO IT THIS WAY; YOUR CODE WILL BE BUGGY!!!\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(x -> (;x.a); hoist_type=true)\nstable_hash(MyType(missing)) == stable_hash(MyType(nothing)) ## OOPS, we wanted these to be different but this returns `true`","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Setting the flag to hoist_type=true here causes the type of the missing and nothing to be hoisted, since the field a is a concrete type in the return value of Transformer's function. Since only the type of these two values is hashed, their hashes now collide. If the field of the pre-transformed type a was concrete, there wouldn't be any problem, because its type would be hashed, and that would include either the Missing or Nothing in the type hash.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"For this reason, it is better to use pick_fields and omit_fields to select or remove fields from a type you want to transform.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"struct MyType\n    a::Any\nend\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(x -> (;x.a); hoist_type=false)\nstable_hash(MyType(missing)) != stable_hash(MyType(nothing)) # true\n\n# NOTE: pick_fields sets `hoist_type=true` by default; it is set here explicitly to\n# clearly illustrate\n# what is happening.\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(pick_fields(:a); hoist_type=true)\nstable_hash(MyType(missing)) != stable_hash(MyType(nothing)) # this is also `true` and is faster than the previous implementation","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Bottom line: It is not sufficient for the function to be type stable to safely set hoist_type=true. If the return value of your transformer function over its known domain returns multiple distinct concrete types, you can run into problems.","category":"page"},{"location":"#Customizing-Type-Hashes","page":"Manual","title":"Customizing Type Hashes","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Types are hashed by hashing the return value of StableHashTraits.transform_type when hashing an object's type and the return value of StableHashTraits.transform_type_value when hashing a type as a value (e.g. stable_hash(Int)). The documentation for these functions provide several examples of their usage.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In addition there is some structure of the type that is always hashed:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"fieldtypes(T) of any StructType.DataType (e.g. StructType.Struct)\neltype(T) of any StructType.ArrayType or StructType.DictType or AbstractRange","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"These get added internally so as to ensure that the type-hoisting described above can rely on eltypes and fieldtypes storing all downstream children's concrete types.","category":"page"}]
}
