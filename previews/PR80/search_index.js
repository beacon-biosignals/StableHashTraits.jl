var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"stable_hash\nHashVersion\nStableHashTraits.transformer\nStableHashTraits.Transformer\npick_fields\nomit_fields\nStableHashTraits.TransformIdentity\nStableHashTraits.hoist_type\nStableHashTraits.transform_type\nStableHashTraits.transform_type_value\nnameof_string\nStableHashTraits.module_nameof_string\nStableHashTraits.is_ordered\nStableHashTraits.hash_sort_by\nStableHashTraits.parent_context\nStableHashTraits.@context\nWithTypeNames\nTablesEq","category":"page"},{"location":"api/#StableHashTraits.stable_hash","page":"API","title":"StableHashTraits.stable_hash","text":"stable_hash(x, context; alg=sha256)\nstable_hash(x; alg=sha256, version)\n\nCreate a stable hash of the given objects. As long as the context remains the same, this hash is intended to remain unchanged across julia versions. The built-in context is HashVersion{N}, and if you specify a version, this is equivalent to explicitly passing HashVersion{version}.\n\nThe version must be explicitly specified: if a new hash version is provided in a future release, your result will not change.\n\nYou customize how hashes are computed using transformer.\n\nTo change the hash algorithm used, pass a different function to alg. It accepts any sha related function from SHA or any function of the form hash(x::AbstractArray{UInt8}, [old_hash]).\n\nThe context value gets passed as the second argument to transformer, see Using Contexts for details.\n\nSee Also\n\ntransformer\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.HashVersion","page":"API","title":"StableHashTraits.HashVersion","text":"HashVersion{V}()\n\nThe default hash_context used by stable_hash. There are currently two versions (4-5) The most recent version should be favored, unless backwards compatibility is necessary.\n\nSince the version is required to be explicitly passed to stable_hash, hash values for default hash methods (those not overwritten by users) will not change, even if new hash versions are developed.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.transformer","page":"API","title":"StableHashTraits.transformer","text":"StableHashTraits.transformer(::Type{T}, [context]) where {T}\n\nReturn Transformer indicating how to modify an object of type T before hashing it. Methods with a context are called first, and if no method for that type exists there is a fallback that calls the method without a context. Users can therefore implement a method with a context object to customize transformations for that context only, or a single argument method when they wish to affect the transformation across all contexts that don't have a context specific method.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.Transformer","page":"API","title":"StableHashTraits.Transformer","text":"StableHashTraits.Transformer(fn=identity, result_method=nothing;\n                             hoist_type=StableHashTraits.hoist_type(fn))\n\nWraps the function used to transform values before they are hashed. The function is applied (fn(x)), and then its result is hashed according to the trait @something result_method StructType(fn(x)).\n\nThe flag hoist_type indicates if it is safe to hoist type hashes outside of loops. If set to true your has will be computed more quickly. However, this hoisting is only valid when the pre-transformed type is sufficient to disambiguate the hashed values that are produced downstream AND when the post-transformed types that are concrete depend only on pre-transformed types that are themselves concrete.\n\ndanger: Use `hoist_type=true` with care\nIt is easy to introduce subtle bugs that occur in rare edge cases when using hoist_type=true. Refer to Optimizing Custom Transformers for a detailed discussion and examples of when you can safely set hoist_type=true. It is better to use a pre-defined function such as pick_fields or omit_fields.\n\nSee Also\n\ntransformer\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.pick_fields","page":"API","title":"StableHashTraits.pick_fields","text":"pick_fields(x, fields::Symbol...)\npick_fields(x, fields::NTuple{<:Any, Symbol})\npick_fields(fields::Symbol...)\npick_fields(fields::NTuple{<:Any, Symbol})\n\nReturn an object including fields from the fields of x, as per getfield. Curried versions exist, which return a function for selecting the given fields.\n\nThis function differs from returning a named tuple of fields (e.g. x -> (;x.a, x.b)) in that it does not narrow the types of the returned fields. A field of type Any of x is a field of type Any in the returned value. This ensures that pickfields can be safely used with `hoisttypeof [Transformer`](@ref).\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.omit_fields","page":"API","title":"StableHashTraits.omit_fields","text":"omit_fields(x, fields::Symbol...)\nomit_fields(x, fields::NTuple{<:Any, Symbol})\nomit_fields(fields::Symbol...)\nomit_fields(fields::NTuple{<:Any, Symbol})\n\nReturn an object excluding fields from the fields of x, as per getfield. Curried versions exist, which return a function for selecting the given fields.\n\nThis function differs from returning a named tuple of fields (e.g. x -> (;x.a, x.b)) in that it does not narrow the types of the returned fields. A field of type Any of x is a field of type Any in the returned value. This ensures that pickfields can be safely used with `hoisttypeof [Transformer`](@ref).\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.TransformIdentity","page":"API","title":"StableHashTraits.TransformIdentity","text":"StableHashTraits.TransformIdentity(x)\n\nSignal that the type x should not be transformed in the usual way, but by hashing x directly. This is useful when you want to hash both x the way it would normally be hashed without a specialized method of transformer along with some metadata. Without this wrapper, returning (metadata(x), x) from the transforming function would cause an infinite regress (adding metadata(x) upon each call).\n\nExample\n\nstruct MyArray <: AbstractVector{Int}\n    data::Vector{Int}\n    meta::Dict{String, String}\nend\n# other array methods go here...\nfunction StableHashTraits.transformer(::Type{<:MyArray})\n    return Transformer(x -> (x.meta, TransformIdentity(x)); hoist_type=true)\nend\n\nIn this example we hash both some metadata about a custom array, and each of the elements of x\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.hoist_type","page":"API","title":"StableHashTraits.hoist_type","text":"StableHashTraits.hoist_type(fn)\n\nReturns true if it is known that fn preservess type structure ala Transformer. See Optimizing Custom Transformers for details. This is false by default for all functions but identity and module_nameof_string. You can define a method of this function for your own fn's to signal that their results can be safely optimized via hoisting the type hash outside of loops.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.transform_type","page":"API","title":"StableHashTraits.transform_type","text":"transform_type(::Type{T}, [context])\n\nThe value to hash for type T when hashing an object's type. Users of StableHashTraits can implement a method that accepts one (T) or two arguments (T and context). If no method is implemented, the fallback transform_type value uses StructType(T) to decide how to hash T; this is documented under What gets hashed?.\n\nAny types returned by transform_type has transform_type applied to it, so make sure that you only return types when they are some nested component of your type (do not return T!!)\n\nThis method is used to add additional data to the hash of a type. Internally, the data listed below is always added, outside of the call to transform_type:\n\nfieldtypes(T) of any StructType.DataType (e.g. StructType.Struct)\neltype(T) of any StructType.ArrayType or StructType.DictType or AbstractRange\n\nThese components of the type need not be returned by transform_type and you cannot prevent them from being included in a type's hash, since otherwise the assumptions necessary for efficient hash computation would be violated.\n\nExamples\n\nType Parameters\n\nTo include additional type parameters in a type's hash, you can overwrite transform_type\n\nstruct MyStruct{T,K}\n    wrapped::T\nend\n\nfunction StableHashTraits.transform_type(::Type{<:MyStruct{T,K}})\n    return \"MyStruct\", K\nend\n\nBy adding this method for type_structure both K and T will impact the hash, T because it is included in fieldtypes(<:MyStruct) and K because it is included in type_structure(<:MyStruct).\n\nIf you do not own the type you want to customize, you can specialize type_structure using a specific hash context.\n\nusing Intervals\n\nStableHashTraits.@context IntervalEndpointsMatter\n\nfunction HashTraits.type_structure(::Type{<:I}, ::IntervalEndpointsMatter) where {T, L, R, I<:Interval{T, L, R}}\n    return (L, R)\nend\n\ncontext = IntervalEndpointsMatter(HashVersion{5}())\nstable_hash(Interval{Closed, Open}(1, 2), context) !=\n    stable_hash(Interval{Open, Closed}(1, 2), context) # true\n\nSee Also\n\ntransformer @context\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.transform_type_value","page":"API","title":"StableHashTraits.transform_type_value","text":"transform_type_value(::Type{T}, [trait], [context]) where {T}\n\nThe value that is hashed for type T when hashing a type as a value (e.g. stable_hash(Int)). You can return types (e.g. type parameters of T), but do not return T or you will get a stack overflow.\n\nSee Also\n\ntransformer StableHashTraits.transform_type\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.nameof_string","page":"API","title":"StableHashTraits.nameof_string","text":"nameof_string(::Type{T})\nnameof_string(T::Module)\nnameof_string(::T) where {T}\n\nGet a stable name of T. This is a helpful utility for writing your own methods of StableHashTraits.transform_type and StableHashTraits.transform_type_value. The stable name is computed from nameof. Anonymous names (e.g. module_nameof_string(x -> x+1)) throw an error, as no stable name is possible in this case.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.module_nameof_string","page":"API","title":"StableHashTraits.module_nameof_string","text":"module_nameof_string(::Type{T})\nmodule_nameof_string(T::Module)\nmodule_nameof_string(::T) where {T}\n\nGet a (mostly!) stable name of T. This is a helpful utility for writing your own methods of StableHashTraits.transform_type and StableHashTraits.transform_type_value. The stable name includes the name of the module that T was defined in. Any uses of Core are replaced with Base to keep the name stable across versions of julia. Anonymous names (e.g. module_nameof_string(x -> x+1)) throw an error, as no stable name is possible in this case.\n\ndanger: A type's module often changes\nThe module of many types are considered an implementation detail and can change between non-breaking versions of a package. For this reason uses of module_nameof_string must be explicitly specified by user of StableHashTraits. This function is not used internally or HashVersion{V} for types that are not defined in StableHashTraits.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.is_ordered","page":"API","title":"StableHashTraits.is_ordered","text":"is_ordered(x)\n\nIndicates whether the order of the elements of object x are important to its hashed value. If false, x's elements will first be collected and sort'ed before hashing them. When calling sort, hash_sort_by is passed as the by keyword argument. If x is a DictType, the elements are sorted by their keys rather than their elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.hash_sort_by","page":"API","title":"StableHashTraits.hash_sort_by","text":"`hash_sort_by(x)`\n\nDefines how the elements of a hashed container x are sorted if is_ordered of x returns false. The return value of this function is passed to sort as the by keyword.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.parent_context","page":"API","title":"StableHashTraits.parent_context","text":"StableHashTraits.parent_context(context)\n\nReturn the parent context of the given context object. (See transformer and StableHashTraits.@context for details of using context).\n\nThis is normally all that you need to know to implement a new context. However, if your context is expected to be the root context—one that does not fallback to any parent (akin to HashVersion)—then there may be a bit more work involved. In this case, parent_context should return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.@context","page":"API","title":"StableHashTraits.@context","text":"StableHashTraits.@context MyContext\n\nShorthand for declaring a hash context.\n\nContexts are used to customize the behavior of a hash for a type you don't own, by passing the context as the second argument to stable_hash, and specializing methods of transformer or StableHashTraits.transform_type on your context (see example below).\n\nThe clause @context MyContext is re-written to:\n\nstruct MyContext{T}\n    parent::T\nend\nStableHashTraits.parent_context(x::MyContext) = x.parent\n\nThe parent context is typically another custom context, or the root context, such as HashVersion{5}().\n\nExample\n\nStableHashTraits.@context NumberAbs\ntransformer(::Type{<:Number}, ::NumberAbs) = Transformer(abs; hoist_type=true)\nstable_hash(10, NumberAbs(HashVersion{5}())) == stable_hash(-10, NumberAbs(HashVersion{5}()))\n\nSee Also\n\nparent_context\n\n\n\n\n\n","category":"macro"},{"location":"api/#StableHashTraits.WithTypeNames","page":"API","title":"StableHashTraits.WithTypeNames","text":"WithTypeNames(parent_context)\n\nIn this hash context, StableHashTraits.transform_type returns module_nameof_string for all types, in contrast to the default behavior (which mostly uses nameof_string(StructType(T))).\n\nwarn: Unstable\nmodule_nameof_string's return value can change with non-breaking changes if e.g. the module of a function or type is changed because it's considered an implementation detail of a package.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.TablesEq","page":"API","title":"StableHashTraits.TablesEq","text":"TablesEq(parent_context)\n\nIn this hash context the type and structure of a table do not impact the hash that is created, only the set of columns (as determined by Tables.columns), and the hash of the individual columns matter.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Internal-Methods","page":"Internal Functions","title":"Internal Methods","text":"","category":"section"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"Documented methods that are not part of the public API.","category":"page"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"StableHashTraits.hash_type!\nStableHashTraits.HashState\nStableHashTraits.similar_hash_state\nStableHashTraits.start_nested_hash!\nStableHashTraits.end_nested_hash!\nStableHashTraits.update_hash!\nStableHashTraits.compute_hash!","category":"page"},{"location":"internal/#StableHashTraits.hash_type!","page":"Internal Functions","title":"StableHashTraits.hash_type!","text":"hash_type!(hash_state, context, T)\n\nHash type T in the given context, updating hash_state.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.HashState","page":"Internal Functions","title":"StableHashTraits.HashState","text":"HashState(alg, context)\n\nGiven a function that implements the hash algorithm to use and the current hash context, setup the necessary state to track updates to hashing as we traverse an object's structure and return it.\n\n\n\n\n\n","category":"type"},{"location":"internal/#StableHashTraits.similar_hash_state","page":"Internal Functions","title":"StableHashTraits.similar_hash_state","text":"similar_hash_state(state::HashState)\n\nAkin to similar for arrays, this constructs a new object of the same concrete type as state\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.start_nested_hash!","page":"Internal Functions","title":"StableHashTraits.start_nested_hash!","text":"start_nested_hash!(state::HashState)\n\nReturn an updated state that delimits hashing of a nested structure; calls made to update_hash! after startnestedhash! will be handled as nested elements up until end_nested_hash! is called.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.end_nested_hash!","page":"Internal Functions","title":"StableHashTraits.end_nested_hash!","text":"end_nested_hash!(state::HashState)\n\nReturn an updated state that delimints the end of a nested structure.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.update_hash!","page":"Internal Functions","title":"StableHashTraits.update_hash!","text":"update_hash!(state::HashState, bytes)\n\nReturns the updated hash state given a set of bytes (either a tuple or array of UInt8 values).\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.compute_hash!","page":"Internal Functions","title":"StableHashTraits.compute_hash!","text":"compute_hash!(state::HashState)\n\nReturn the final hash value to return for state\n\n\n\n\n\n","category":"function"},{"location":"#StableHashTraits","page":"Manual","title":"StableHashTraits","text":"","category":"section"},{"location":"#Use-Case-and-Design-Rationale","page":"Manual","title":"Use Case and Design Rationale","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"StableHashTraits is designed to be used in cases where there is an object you wish to serialize in a content-addressed cache. How and when objects pass the same input to a hashing algorithm is meant to be predictable and well defined, so that the user can reliably define methods of transformer to modify this behavior.","category":"page"},{"location":"#What-gets-hashed?","page":"Manual","title":"What gets hashed?","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"When you call stable_hash(x; version=4), StableHashTraits hashes both the value x and its type T. Rather than hashing the type T itself directly, in most cases instead StructTypes.StructType(T) is hashed, using StructTypes.jl. For example, since the \"StructType\" of Float64 and Float32 are both NumberType, when hashing Float64 and Float32 values, value and NumberType are hashed. This provides a simple trait-based system that doesn't need to rely on internal details. See below for more details.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"You can customize how the value is hashed using StableHashTraits.transformer, and how its type is hashed using StableHashTraits.transform_type. If you need to customize either of these functions for a type that you don't own, you can use a @context to avoid type piracy.","category":"page"},{"location":"#StructType.DataType","page":"Manual","title":"StructType.DataType","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"StructType.DataType denotes a type that is some kind of \"record\"; i.e. its content is defined by the fields (getfield(f) for f in fieldnames(T)) of the type. Since it is the default, it is used to hash most types.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the value, each field value (getfield(f) for f in fieldnames(T)) is hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If StructType(T) <: StructTypes.UnorderedStruct (the default), the field values are first sorted by the lexographic order of the field names.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The type of a data type is hashed using string(nameof(T)), the fieldnames(T), (sorting them for UnorderedStruct), along with a hash of the type of each element of fieldtypes(T) according to their StructType.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"No type parameters are hashed by default. To hash these you need to specialize on StableHashTraits.transform_type for your struct. Note that because fieldtypes(T) is hashed, you don't need to do this unless your type parameters are not used in the specification of your field types.","category":"page"},{"location":"#StructType.ArrayType","page":"Manual","title":"StructType.ArrayType","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"ArrayType is used when hashing a sequence of values.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the value, each element of an array type is hashed using iterate. If the object isa AbstractArray, the size(x) of the object is also hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If StableHashTraits.is_ordered returns false the elements are first sorted according to StableHashTraits.hash_sort_by.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the type, the string \"StructTypes.ArrayType\" is hashed (meaning that the kind of array won't matter to the hash value), and the type of the elype is hashed, according to its StructType. If the type <: AbstractArray, the ndims(T) is hashed.","category":"page"},{"location":"#StructTypes.DictType","page":"Manual","title":"StructTypes.DictType","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"To hash the value, each key-value pair of a dict type is hashed, as returned by StructType.keyvaluepairs(x).","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If StableHashTraits.is_ordered returns false (which is the default return value) the pairs are first sorted according their keys using StableHashTraits.hash_sort_by.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the type, the string \"StructTypes.DictType\" is hashed (meaning that the kind of dictionary won't matter), and the type of the keytype and valtype is hashed, according to its StructType.","category":"page"},{"location":"#AbstractRange","page":"Manual","title":"AbstractRange","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"AbstractRange constitutes an exception to the rule that we use StructType: for efficient hashing, ranges are treated as another first-class container object, separate from array types.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The value is hashed as (first(x), step(x), last(x)).","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The type is hashed as \"Base.AbstractRange\" along with the type of the eltype, according to its StructType. Thus, the type of range doesn't matter (just that it is a range).","category":"page"},{"location":"#StructTypes{Number/String/Bool}Type","page":"Manual","title":"StructTypes{Number/String/Bool}Type","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"To hash the value, the result of Base.writeing the object is hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To hash the type, the value of string(\"StructType.\", nameof_string(StructType(T)))) is used (c.f. StableHashTraits.nameof_string for details). Note that this means the type of the value itself is not being hashed, rather a string related to its struct type.","category":"page"},{"location":"#StructType.CustomStruct","page":"Manual","title":"StructType.CustomStruct","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"For any StructType.CustomStruct, the object is first StructType.lowered and the result is hashed according to the lowered StructType.","category":"page"},{"location":"#missing-and-nothing","page":"Manual","title":"missing and nothing","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"There is no value hashed for missing or nothing; the type is hashed as the string \"Base.Missing\" and \"Base.Nothing\" respectively. Note in particular the string \"Base.Missing\" does not have the same hash as missing, since the former would have its struct type hashed.","category":"page"},{"location":"#StructType.{Null/Singleton}Type","page":"Manual","title":"StructType.{Null/Singleton}Type","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Null and Singleton types are hashed solely according to their type (no value is hashed)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Their types is hashed by StableHashTraits.nameof_string This means the module of the type does not matter: the module of a type is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a type.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"[!NOTE] If you wish to disambiguate functions or types that have the same name but that come from different modules you can overload StableHashTraits.transform_type for those functions. If you want to include the module name for a broad set of types, rather than explicitly specifying a module name for each type, you may want to consider calling StableHashTraits.module_nameof_string in the body of your transform_type method. This can avoid a number of footguns when including the module names: for example, module_nameof_string renames Core to Base to elide Base julia changes to the location of a functions between these two modules and it renames pluto workspace modules to prevent structs from having a different hash each time the notebook is run.","category":"page"},{"location":"#Function","page":"Manual","title":"Function","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Function values are hashed according to their their fields (getfield(f) for f in fieldnames(f)) as per StructType.UnorderedStruct; functions can have fields when they are curried (e.g. ==(2)), and so, for this reason, the fields are included in the hash by default.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The type of the function is hashed according to its StableHashTraits.nameof_string, therefore excluding its module. The exact module of a function is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a function.","category":"page"},{"location":"#Type","page":"Manual","title":"Type","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"When hashing a type as a value (e.g. stable_hash(Int; version=4)) the value of `StableHashTraits.nameof_string is hashed. The exact module of a type is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a type.","category":"page"},{"location":"#Examples","page":"Manual","title":"Examples","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"All of the following hash examples follow directly from the definitions above, but may not be so obvious to the reader.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Most of the behaviors described below can be customized/changed by using your own hash StableHashTraits.@context, which can be passed as the second argument to stable_hash. StableHashTraits tries to defer to StructTypes for most defaults instead of making more opinionated choices.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The order of NamedTuple pairs does not matter, because NamedTuple has a struct type of UnorderedStruct:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash((;a=1,b=2); version=4) == stable_hash((;b=2,a=1); version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Two structs with the same fields and name hash equivalently, because the default struct type is UnorderedStruct:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"module A\n    struct X\n        bar::Int\n        foo::Float64\n    end\nend\n\nmodule B\n    struct X\n        foo::Float64\n        bar::Int\n    end\nend\n\nstable_hash(B.X(2, 1); version=4) == stable_hash(A.X(1, 2); version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Different array types with the same content hash to the same value:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash(view([1,2,3], 1:2); version=4) == stable_hash([1,2]; version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Byte-equivalent arrays of all NumberType values will hash to the same value:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash([0.0, 0.0]; version=4) == stable_hash([0, 0]; version=4)\nstable_hash([0.0f0, 0.0f0]; version=4) != stable_hash([0, 0]; version=4) # not byte equivalent","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Also, even though the bytes are the same, since the size is hashed, we have:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash([0.0f0, 0.0f0]; version=4) != stable_hash([0]; version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If the eltype has a different StructType, no collision will occur:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash(Any[0.0, 0.0]; version=4) != stable_hash([0, 0]; version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Even if the mathematical values are the same, if the bytes are not the same no collision will occur:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash([1.0, 2.0]; version=4) != stable_hash([1, 2]; version=4)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Two types with the same name but different type parameters will hash the same (unless you define a transform_type_value method for your type to include those type parameters in its return value):","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"struct MyType{T} end\nstable_hash(MyType{:a}) == stable_hash(MyType{:b}) # true","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Numerical changes will, of course, change the hash. One way this can catch you off guard are some differences in StaticArray outputs between julia versions:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> using StaticArrays, StableHashTraits;\n\njulia> begin\n        rotmatrix2d(a) = @SMatrix [cos(a) sin(a); -sin(a) cos(a)]\n        rotate(a, p) = rotmatrix2d(a) * p\n        rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n    end;","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In julia 1.9.4:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"\njulia> bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=4))\n\"4ccdc172688dd2b5cd50ba81071a19217c3efe2e3b625e571542004c8f96c797\"\n\njulia> rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n2-element SVector{2, Float64} with indices SOneTo(2):\n  7.419375817039376e-17\n -0.5953242152248626","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In julia 1.6.7","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=4))\n\"3b8d998f3106c05f8b74ee710267775d0d0ce0e6780c1256f4926d3b7dcddf9e\"\n\njulia> rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n2-element SVector{2, Float64} with indices SOneTo(2):\n  5.551115123125783e-17\n -0.5953242152248626","category":"page"},{"location":"#Basic-Customization","page":"Manual","title":"Basic Customization","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"To customize hashing, you typically want to simply override a method of StableHashTraits.transformer. This should return a function wrapped in a StableHashTraits.Transformer object that will be applied to an object and its result is the actual value that gets hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"using StableHashTraits\nusing StableHashTraits: Transformer\nusing Dates\n\nstruct MyType\n   data::Vector{UInt8}\n   metadata::Dict{Symbol, Any}\nend\n# ignore `metadata`, `data` will be hashed using fallbacks for `AbstractArray` type\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(pick_fields(:data))\n# NOTE: `pick_fields` is a helper function implemented by `StableHashTraits`\n# it creates a named tuple with the given object fields; in the above code it is used\n# in its curried form e.g. `pick_fields(:data)` is the same as `x -> pick_fields(x, :data)`\na = MyType(read(\"myfile.txt\"), Dict{Symbol, Any}(:read => Dates.now()))\nb = MyType(read(\"myfile.txt\"), Dict{Symbol, Any}(:read => Dates.now()))\nstable_hash(a; version=4) == stable_hash(b; version=4) # true","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"!!! note \"Use pick_fields and omit_fields     It is recommended you use pick_fields or omit_fields when you simply want to select some subset of fields to be hashed, as they allow for more optimized hashes than directly returning a named tuple of a field subset.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"StableHashTraits.Transformer takes a second positional argument which is the StructType you wish to use on the transformed return value. By default StructType is applied to the result to determine this automatically, but in some cases it can be useful to modify this trait by passing a second argument.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"tip: Avoid StackOverflow using `TransformIdentity`\nMake sure you don't return the object itself as an element of some collection. It can be tempting to do e.g. (mymetadata(x), x) as a return value for transformer's function. Instead you can use StableHashTraits.TransformIdentity to make sure this won't lead to an infinite regress: e.g. (mymetadata(x), TransformIdentity(x)). Using StableHashTraits.TransformIdentity will cause x's transformed result to be x itself, thereby avoiding the infinite regress.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"transformer customizes how the content of your object is hashed. The hash of the type is customized separately using StableHashTraits.transform_type.","category":"page"},{"location":"#Using-Contexts","page":"Manual","title":"Using Contexts","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Because not every package knows about either StableHashTraits or StructTypes, there may be types you don't own that you want to customize the hash of. In this scenario you should define a context object that you pass as the second argument to stable_hash and define a method of transformer that dispatches on this context object as its second argument.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"A context is simply an arbitrary object that defines a method for StableHashTraits.parent_context. By default the context to stable_hash is HashVersion{version}(). Because of parent_context, contexts can be stacked, and a HashVersion should be at the bottom of the stack. There are fallback methods for transformer that look at the value implemented by the parent context. In this way you need only define methods for the types you want to customize.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"For example, this customization makes the ordering of named tuple keys affect the hash value.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> begin\n        struct NamedTuplesOrdered{T}\n            parent::T\n        end\n        StableHashTraits.parent_context(x::NamedTuplesOrdered) = x.parent\n        function transformer(::Type{<:NamedTuple}, ::NamedTuplesOrdered)\n            Transformer(identity, StructTypes.OrderedStruct())\n        end\n        context = NamedTuplesOrdered(HashVersion{5}())\n       end;\n\njulia> stable_hash((; a=1:2, b=1:2), context) != stable_hash((; b=1:2, a=1:2), context)\ntrue","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Without this context, the keys are first sorted because StructType(NamedTuple) isa StructType.UnorderedStruct.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"As a short hand you can use StableHashTraits.@context for creating simple contexts, like the one above. Like so:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> begin\n        @context NamedTuplesOrdered\n        function transformer(::Type{<:NamedTuple}, ::NamedTuplesOrdered)\n            Transformer(identity, StructTypes.OrderedStruct())\n        end\n        context = NamedTuplesOrdered(HashVersion{5}())\n       end;\n\njulia> stable_hash((; a=1:2, b=1:2), context) != stable_hash((; b=1:2, a=1:2), context)\ntrue","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"There are several useful, predefined contexts available in StableHashTraits that can be used to change how hashing works:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"WithTypeNames\nTablesEq","category":"page"},{"location":"#Optimizing-Custom-Transformers","page":"Manual","title":"Optimizing Custom Transformers","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"By default, stable hash traits follows a safe, but slower code path for arbitrary functions passed to Transformer. However, in some cases it can use a faster code path, given that some assumptions about the types returned by the transforming function are maintained. The identity function and the functions returned by pick_fields and omit_fields use this faster code path by default.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In particular, a keyword argument to Transformer, hoist_type can be set to true to use this faster code path. Functions that implement StableHashTraits.hoist_type(::typeof(fn)) can return true to signal that they are safe when using this faster code path. This function is called to determine the default value of hoist_type when this function is passed as the first argument to Transformer.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The exact criteria for when this code path is unsafe are somewhat subtle, and will be described below, along with some examples. However, you can always safely use hoist_type=true either when the function always returns the same type (e.g. it transforms all inputs into String values) OR when the following three criteria are met:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The type that transformer dispatches on is concrete.\nThe type that transformer dispatches on contains no abstract types: that is, for any contained array type or dict types, their eltypes are concrete and for any contained data type, its fieldtypes are concrete.\nThe function you pass to Transformer is type stable","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"When set to true, hoist_type=true hashes the type of the pre-transformed object, prior to looping over the contents of the post-transformed object: its fields (for a data type) or the elements (for an array or dict type). Once the contents of the object are being looped over, hashing the type of each concrete-typed element or field is skipped. For example, when hashing an Array{Int} the Int will only be hashed once, not once for every element.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"When hoist_type=false (the default for most functions) the type of the return value from transformer is hashed alongside the transformed value. This can be a lot slower, but ensures the that no unexpected hash collisions will occur.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"More precisely, this hoisting is only valid when one of these two criteria are satisfied:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"the pre-transformed type is sufficient to disambiguate the hash of the downstream object values absent their object types.\nthe post-transformed types do not change unless the caller inferred type of the input it depends on changes","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The latter criteria is more stringent than type stability. A function input could have a caller-inferred type of Any, be type stable, and return either Char or an Int depending on the value of its input. Such a function would violate this second criteria.","category":"page"},{"location":"#Examples-2","page":"Manual","title":"Examples","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"When is the pre-transformed type sufficient to disambiguate hashed values? First, many type-unstable functions should be considered unable to meet this criteria. The only time they are certain to be safe is when the values disambiguate the hash regardless of the type.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"For instance, the assmuptions of hoist_type=true would be violated by the function x -> x < 0 : Char(0) ? Int32(0) because the bits that are hashed downstream are identical, even though the type information that should be hashed with them are different: Char is a StringType and Ing32 is a NumberType.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In contrast, x -> x < 0 : Char(1) : Int32(2) is safe to use with hoist_type=true, because although the type changes, the byte sequence of the value never overlaps, regardless of the type returned. If you are confident the bit sequence will be unique in this way, you could safely use hoist_type=true even though the transformer is type unstable.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Beware! When a type unstable function will be unsafe for a given type depends on the context, because users can define their own type_transform that can lead to more type details being important to the hashed value. For instance, in the default context x -> x < 0 : Int32(0) ? UInt32(0) would be considered safe, since both Int32 and UInt32 have the same type for purposes of hashing (NumberType), but if the user were to write a custom transform_type in a HashExactNumberType context, now this function is no longer safe to use with hoist_type=true.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"These examples hopefully help to clarify when type-unstable functions can lead to unexpected hash collisions with hoist_type=true. However type stable functions can also lead to invalid hashes with hoist_type=true. For example:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"struct MyType\n    a::Any\nend\n# ignore `metadata`, `data` will be hashed using fallbacks for `AbstractArray` type\n# DO NOT DO IT THIS WAY; YOUR CODE WILL BE BUGGY!!!\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(x -> (;x.a); hoist_type=true)\nstable_hash(MyType(missing)) == stable_hash(MyType(nothing)) ## OOPS, we wanted these to be different but this returns `true`","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Setting the flag to hoist_type=true here causes the type of the missing and nothing to be hoisted, since the field a is a concrete type in the return value of Transformer's function. Since only the type of these two values is hashed, their hashes now collide. If the field of the pre-transformed type a was concrete, there wouldn't be any problem, because its type would be hashed, and that would include either the Missing or Nothing in the type hash.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"For this reason, it is better to use pick_fields and omit_fields to select or remove fields from a type you want to transform.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"struct MyType\n    a::Any\nend\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(x -> (;x.a); hoist_type=false)\nstable_hash(MyType(missing)) != stable_hash(MyType(nothing)) # true\n\n# NOTE: pick_fields sets `hoist_type=true` by default; it is set here explicitly to\n# clearly illustrate\n# what is happening.\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(pick_fields(:a); hoist_type=true)\nstable_hash(MyType(missing)) != stable_hash(MyType(nothing)) # this is also `true` and is faster than the previous implementation","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Bottom line: It is not sufficient for the function to be type stable to safely set hoist_type=true. If the return value of your transformer function over its known domain returns multiple distinct concrete types, you can run into problems.","category":"page"},{"location":"#Customizing-Type-Hashes","page":"Manual","title":"Customizing Type Hashes","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Types are hashed by hashing the return value of StableHashTraits.transform_type when hashing an object's type and the return value of StableHashTraits.transform_type_value when hashing a type as a value (e.g. stable_hash(Int)). The docs for these functions provide several examples of their usage.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In addition there is some structure of the type that is always hashed:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"fieldtypes(T) of any StructType.DataType (e.g. StructType.Struct)\neltype(T) of any StructType.ArrayType or StructType.DictType or AbstractRange","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"These get added internally so as to ensure that the type-hoisting described above can rely on eltypes and fieldtypes storing all downstream children's concrete types.","category":"page"}]
}
