<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · StableHashTraits.jl</title><meta name="title" content="Manual · StableHashTraits.jl"/><meta property="og:title" content="Manual · StableHashTraits.jl"/><meta property="twitter:title" content="Manual · StableHashTraits.jl"/><meta name="description" content="Documentation for StableHashTraits.jl."/><meta property="og:description" content="Documentation for StableHashTraits.jl."/><meta property="twitter:description" content="Documentation for StableHashTraits.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>StableHashTraits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Use-Case-and-Design-Rationale"><span>Use Case and Design Rationale</span></a></li><li><a class="tocitem" href="#What-gets-hashed?-(hash-version-4)"><span>What gets hashed? (hash version 4)</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Basic-Customization"><span>Basic Customization</span></a></li><li><a class="tocitem" href="#Using-Contexts"><span>Using Contexts</span></a></li><li><a class="tocitem" href="#Optimizing-Custom-Transformers"><span>Optimizing Custom Transformers</span></a></li><li><a class="tocitem" href="#Customizing-Type-Hashes"><span>Customizing Type Hashes</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li><li><a class="tocitem" href="deprecated/">Deprecated</a></li><li><a class="tocitem" href="internal/">Internal Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/beacon-biosignals/StableHashTraits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/beacon-biosignals/StableHashTraits.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="StableHashTraits"><a class="docs-heading-anchor" href="#StableHashTraits">StableHashTraits</a><a id="StableHashTraits-1"></a><a class="docs-heading-anchor-permalink" href="#StableHashTraits" title="Permalink"></a></h1><h2 id="Use-Case-and-Design-Rationale"><a class="docs-heading-anchor" href="#Use-Case-and-Design-Rationale">Use Case and Design Rationale</a><a id="Use-Case-and-Design-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Case-and-Design-Rationale" title="Permalink"></a></h2><p>StableHashTraits is designed to be used in cases where there is an object you wish to serialize in a content-addressed cache. How and when objects pass the same input to a hashing algorithm is meant to be predictable and well defined, so that the user can reliably define methods of <code>transformer</code> to modify this behavior.</p><h2 id="What-gets-hashed?-(hash-version-4)"><a class="docs-heading-anchor" href="#What-gets-hashed?-(hash-version-4)">What gets hashed? (hash version 4)</a><a id="What-gets-hashed?-(hash-version-4)-1"></a><a class="docs-heading-anchor-permalink" href="#What-gets-hashed?-(hash-version-4)" title="Permalink"></a></h2><p>This covers the behavior when using the latest hash version (4). You can read the documentation for hash version 1 <a href="https://github.com/beacon-biosignals/StableHashTraits.jl/blob/v1.0.0/README.md">here</a> and hash version 2-3 <a href="https://github.com/beacon-biosignals/StableHashTraits.jl/blob/v1.1.8/README.md">here</a>.</p><p>When you call <code>stable_hash(x; version=4)</code>, StableHashTraits hashes both the value <code>x</code> and its type <code>T</code>. Rather than hashing the type <code>T</code> itself directly, in most cases instead <code>StructTypes.StructType(T)</code> is hashed, using <a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a>. For example, since the &quot;StructType&quot; of Float64 and Float32 are both <code>NumberType</code>, when hashing Float64 and Float32 values, value and <code>NumberType</code> are hashed. This provides a simple trait-based system that doesn&#39;t need to rely on internal details. See below for more details.</p><p>You can customize how the value is hashed using <a href="api/#StableHashTraits.transformer"><code>StableHashTraits.transformer</code></a>, and how its type is hashed using <a href="api/#StableHashTraits.transform_type"><code>StableHashTraits.transform_type</code></a>. If you need to customize either of these functions for a type that you don&#39;t own, you can use a <a href="https://beacon-biosignals.github.io/StableHashTraits.jl/stable/api/#StableHashTraits.@context">@context</a> to avoid type piracy.</p><h3 id="StructType.DataType"><a class="docs-heading-anchor" href="#StructType.DataType"><code>StructType.DataType</code></a><a id="StructType.DataType-1"></a><a class="docs-heading-anchor-permalink" href="#StructType.DataType" title="Permalink"></a></h3><p><code>StructType.DataType</code> denotes a type that is some kind of &quot;record&quot;; i.e. its content is defined by the fields (<code>getfield(f) for f in fieldnames(T)</code>) of the type. Since it is the default, it is used to hash most types.</p><p>To hash the value, each field value (<code>getfield(f) for f in fieldnames(T)</code>) is hashed.</p><p>If <code>StructType(T) &lt;: StructTypes.UnorderedStruct</code> (the default), the field values are first sorted by the lexographic order of the field names.</p><p>The type of a data type is hashed using <code>string(nameof(T))</code>, the <code>fieldnames(T)</code>, (sorting them for <code>UnorderedStruct</code>), along with a hash of the type of each element of <code>fieldtypes(T)</code> according to their <code>StructType</code>.</p><p>No type parameters are hashed by default. To hash these you need to specialize on <a href="api/#StableHashTraits.transform_type"><code>StableHashTraits.transform_type</code></a> for your struct. Note that because <code>fieldtypes(T)</code> is hashed, you don&#39;t need to do this unless your type parameters are not used in the specification of your field types.</p><h3 id="StructType.ArrayType"><a class="docs-heading-anchor" href="#StructType.ArrayType"><code>StructType.ArrayType</code></a><a id="StructType.ArrayType-1"></a><a class="docs-heading-anchor-permalink" href="#StructType.ArrayType" title="Permalink"></a></h3><p><code>ArrayType</code> is used when hashing a sequence of values.</p><p>To hash the value, each element of an array type is hashed using <code>iterate</code>. If the object <code>isa AbstractArray</code>, the <code>size(x)</code> of the object is also hashed.</p><p>If <a href="api/#StableHashTraits.is_ordered"><code>StableHashTraits.is_ordered</code></a> returns <code>false</code> the elements are first <code>sort</code>ed according to <a href="api/#StableHashTraits.hash_sort_by"><code>StableHashTraits.hash_sort_by</code></a>.</p><p>To hash the type, the string <code>&quot;StructTypes.ArrayType&quot;</code> is hashed (meaning that the kind of array won&#39;t matter to the hash value), and the type of the <code>elype</code> is hashed, according to its <code>StructType</code>. If the type <code>&lt;: AbstractArray</code>, the <code>ndims(T)</code> is hashed.</p><h3 id="StructTypes.DictType"><a class="docs-heading-anchor" href="#StructTypes.DictType"><code>StructTypes.DictType</code></a><a id="StructTypes.DictType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.DictType" title="Permalink"></a></h3><p>To hash the value, each key-value pair of a dict type is hashed, as returned by <code>StructType.keyvaluepairs(x)</code>.</p><p>If <a href="api/#StableHashTraits.is_ordered"><code>StableHashTraits.is_ordered</code></a> returns <code>false</code> (which is the default return value) the pairs are first <code>sort</code>ed according their keys using <a href="api/#StableHashTraits.hash_sort_by"><code>StableHashTraits.hash_sort_by</code></a>.</p><p>To hash the type, the string <code>&quot;StructTypes.DictType&quot;</code> is hashed (meaning that the kind of dictionary won&#39;t matter), and the type of the <code>keytype</code> and <code>valtype</code> is hashed, according to its <code>StructType</code>.</p><h3 id="AbstractRange"><a class="docs-heading-anchor" href="#AbstractRange"><code>AbstractRange</code></a><a id="AbstractRange-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractRange" title="Permalink"></a></h3><p><code>AbstractRange</code> constitutes an exception to the rule that we use <code>StructType</code>: for efficient hashing, ranges are treated as another first-class container object, separate from array types.</p><p>The value is hashed as <code>(first(x), step(x), last(x))</code>.</p><p>The type is hashed as <code>&quot;Base.AbstractRange&quot;</code> along with the type of the <code>eltype</code>, according to its <code>StructType</code>. Thus, the type of range doesn&#39;t matter (just that it is a range).</p><h3 id="StructTypes{Number/String/Bool}Type"><a class="docs-heading-anchor" href="#StructTypes{Number/String/Bool}Type"><code>StructTypes{Number/String/Bool}Type</code></a><a id="StructTypes{Number/String/Bool}Type-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes{Number/String/Bool}Type" title="Permalink"></a></h3><p>To hash the value, the result of <code>Base.write</code>ing the object is hashed.</p><p>To hash the type, the value of <code>string(&quot;StructType.&quot;, nameof_string(StructType(T))))</code> is used (c.f. <a href="api/#StableHashTraits.nameof_string"><code>StableHashTraits.nameof_string</code></a> for details). Note that this means the type of the value itself is not being hashed, rather a string related to its struct type.</p><h3 id="StructType.CustomStruct"><a class="docs-heading-anchor" href="#StructType.CustomStruct"><code>StructType.CustomStruct</code></a><a id="StructType.CustomStruct-1"></a><a class="docs-heading-anchor-permalink" href="#StructType.CustomStruct" title="Permalink"></a></h3><p>For any <code>StructType.CustomStruct</code>, the object is first <code>StructType.lower</code>ed and the result is hashed according to the lowered <code>StructType</code>.</p><h3 id="missing-and-nothing"><a class="docs-heading-anchor" href="#missing-and-nothing"><code>missing</code> and <code>nothing</code></a><a id="missing-and-nothing-1"></a><a class="docs-heading-anchor-permalink" href="#missing-and-nothing" title="Permalink"></a></h3><p>There is no value hashed for <code>missing</code> or <code>nothing</code>; the type is hashed as the string <code>&quot;Base.Missing&quot;</code> and <code>&quot;Base.Nothing&quot;</code> respectively. Note in particular the string <code>&quot;Base.Missing&quot;</code> does not have the same hash as <code>missing</code>, since the former would have its struct type hashed.</p><h3 id="StructType.{Null/Singleton}Type"><a class="docs-heading-anchor" href="#StructType.{Null/Singleton}Type"><code>StructType.{Null/Singleton}Type</code></a><a id="StructType.{Null/Singleton}Type-1"></a><a class="docs-heading-anchor-permalink" href="#StructType.{Null/Singleton}Type" title="Permalink"></a></h3><p>Null and Singleton types are hashed solely according to their type (no value is hashed)</p><p>Their types is hashed by <a href="api/#StableHashTraits.nameof_string"><code>StableHashTraits.nameof_string</code></a> This means the module of the type does not matter: the module of a type is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a type.</p><blockquote><p>[!NOTE] If you wish to disambiguate functions or types that have the same name but that come from different modules you can overload <a href="api/#StableHashTraits.transform_type"><code>StableHashTraits.transform_type</code></a> for those functions. If you want to include the module name for a broad set of types, rather than explicitly specifying a module name for each type, you may want to consider calling <a href="api/#StableHashTraits.module_nameof_string"><code>StableHashTraits.module_nameof_string</code></a> in the body of your <code>transform_type</code> method. This can avoid a number of footguns when including the module names: for example, <code>module_nameof_string</code> renames <code>Core</code> to <code>Base</code> to elide Base julia changes to the location of a functions between these two modules and it renames pluto workspace modules to prevent structs from having a different hash each time the notebook is run.</p></blockquote><h3 id="Function"><a class="docs-heading-anchor" href="#Function"><code>Function</code></a><a id="Function-1"></a><a class="docs-heading-anchor-permalink" href="#Function" title="Permalink"></a></h3><p>Function values are hashed according to their their fields (<code>getfield(f) for f in fieldnames(f)</code>) as per <code>StructType.UnorderedStruct</code>; functions can have fields when they are curried (e.g. <code>==(2)</code>), and so, for this reason, the fields are included in the hash by default.</p><p>The type of the function is hashed according to its <a href="api/#StableHashTraits.nameof_string"><code>StableHashTraits.nameof_string</code></a>, therefore excluding its module. The exact module of a function is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a function.</p><h3 id="Type"><a class="docs-heading-anchor" href="#Type"><code>Type</code></a><a id="Type-1"></a><a class="docs-heading-anchor-permalink" href="#Type" title="Permalink"></a></h3><p>When hashing a type as a value (e.g. <code>stable_hash(Int; version=4)</code>) the value of <a href="https://beacon-biosignals.github.io/StableHashTraits.jl/stable/api/#StableHashTraits.nameof_string">`StableHashTraits.nameof_string</a> is hashed. The exact module of a type is often considered an implementation detail, so it is left out to avoid unexpected hash changes from non-breaking releases that change the module of a type.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>All of the following hash examples follow directly from the definitions above, but may not be so obvious to the reader.</p><p>Most of the behaviors described below can be customized/changed by using your own hash <a href="api/#StableHashTraits.@context"><code>StableHashTraits.@context</code></a>, which can be passed as the second argument to <a href="api/#StableHashTraits.stable_hash"><code>stable_hash</code></a>. StableHashTraits tries to defer to StructTypes for most defaults instead of making more opinionated choices.</p><p>The order of NamedTuple pairs does not matter, because <code>NamedTuple</code> has a struct type of <code>UnorderedStruct</code>:</p><pre><code class="language-julia hljs">stable_hash((;a=1,b=2); version=4) == stable_hash((;b=2,a=1); version=4)</code></pre><p>Two structs with the same fields and name hash equivalently, because the default struct type is <code>UnorderedStruct</code>:</p><pre><code class="language-julia hljs">module A
    struct X
        bar::Int
        foo::Float64
    end
end

module B
    struct X
        foo::Float64
        bar::Int
    end
end

stable_hash(B.X(2, 1); version=4) == stable_hash(A.X(1, 2); version=4)</code></pre><p>Different array types with the same content hash to the same value:</p><pre><code class="language-julia hljs">stable_hash(view([1,2,3], 1:2); version=4) == stable_hash([1,2]; version=4)</code></pre><p>Byte-equivalent arrays of all <code>NumberType</code> values will hash to the same value:</p><pre><code class="language-julia hljs">stable_hash([0.0, 0.0]; version=4) == stable_hash([0, 0]; version=4)
stable_hash([0.0f0, 0.0f0]; version=4) != stable_hash([0, 0]; version=4) # not byte equivalent</code></pre><p>Also, even though the bytes are the same, since the size is hashed, we have:</p><pre><code class="language-julia hljs">stable_hash([0.0f0, 0.0f0]; version=4) != stable_hash([0]; version=4)</code></pre><p>If the eltype has a different <code>StructType</code>, no collision will occur:</p><pre><code class="language-julia hljs">stable_hash(Any[0.0, 0.0]; version=4) != stable_hash([0, 0]; version=4)</code></pre><p>Even if the mathematical values are the same, if the bytes are not the same no collision will occur:</p><pre><code class="language-julia hljs">stable_hash([1.0, 2.0]; version=4) != stable_hash([1, 2]; version=4)</code></pre><p>Two types with the same name but different type parameters will hash the same (unless you define a <code>transform_type_value</code> method for your type to include those type parameters in its return value):</p><pre><code class="language-julia hljs">struct MyType{T} end
stable_hash(MyType{:a}) == stable_hash(MyType{:b}) # true</code></pre><p>Numerical changes will, of course, change the hash. One way this can catch you off guard are some differences in <code>StaticArray</code> outputs between julia versions:</p><pre><code class="language-julia hljs">julia&gt; using StaticArrays, StableHashTraits;

julia&gt; begin
        rotmatrix2d(a) = @SMatrix [cos(a) sin(a); -sin(a) cos(a)]
        rotate(a, p) = rotmatrix2d(a) * p
        rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))
    end;</code></pre><p>In julia 1.9.4:</p><pre><code class="language-julia hljs">
julia&gt; bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=4))
&quot;4ccdc172688dd2b5cd50ba81071a19217c3efe2e3b625e571542004c8f96c797&quot;

julia&gt; rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))
2-element SVector{2, Float64} with indices SOneTo(2):
  7.419375817039376e-17
 -0.5953242152248626</code></pre><p>In julia 1.6.7</p><pre><code class="language-julia hljs">julia&gt; bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=4))
&quot;3b8d998f3106c05f8b74ee710267775d0d0ce0e6780c1256f4926d3b7dcddf9e&quot;

julia&gt; rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))
2-element SVector{2, Float64} with indices SOneTo(2):
  5.551115123125783e-17
 -0.5953242152248626</code></pre><h2 id="Basic-Customization"><a class="docs-heading-anchor" href="#Basic-Customization">Basic Customization</a><a id="Basic-Customization-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Customization" title="Permalink"></a></h2><p>To customize hashing, you typically want to simply override a method of <a href="api/#StableHashTraits.transformer"><code>StableHashTraits.transformer</code></a>. This should return a function wrapped in a <a href="api/#StableHashTraits.Transformer"><code>StableHashTraits.Transformer</code></a> object that will be applied to an object and its result is the actual value that gets hashed.</p><pre><code class="language-julia hljs">using StableHashTraits
using StableHashTraits: Transformer
using Dates

struct MyType
   data::Vector{UInt8}
   metadata::Dict{Symbol, Any}
end
# ignore `metadata`, `data` will be hashed using fallbacks for `AbstractArray` type
StableHashTraits.transformer(::Type{&lt;:MyType}) = Transformer(pick_fields(:data))
# NOTE: `pick_fields` is a helper function implemented by `StableHashTraits`
# it creates a named tuple with the given object fields; in the above code it is used
# in its curried form e.g. `pick_fields(:data)` is the same as `x -&gt; pick_fields(x, :data)`
a = MyType(read(&quot;myfile.txt&quot;), Dict{Symbol, Any}(:read =&gt; Dates.now()))
b = MyType(read(&quot;myfile.txt&quot;), Dict{Symbol, Any}(:read =&gt; Dates.now()))
stable_hash(a; version=4) == stable_hash(b; version=4) # true</code></pre><p>!!! note &quot;Use <code>pick_fields</code> and <code>omit_fields</code>     It is recommended you use <a href="api/#StableHashTraits.pick_fields"><code>pick_fields</code></a> or <a href="api/#StableHashTraits.omit_fields"><code>omit_fields</code></a> when you simply want to select some subset of fields to be hashed, as they allow for more optimized hashes than directly returning a named tuple of a field subset.</p><p><a href="api/#StableHashTraits.Transformer"><code>StableHashTraits.Transformer</code></a> takes a second positional argument which is the <code>StructType</code> you wish to use on the transformed return value. By default <code>StructType</code> is applied to the result to determine this automatically, but in some cases it can be useful to modify this trait by passing a second argument.</p><div class="admonition is-success"><header class="admonition-header">Avoid StackOverflow using `TransformIdentity`</header><div class="admonition-body"><p>Make sure you don&#39;t return the object itself as an element of some collection. It can be tempting to do e.g. <code>(mymetadata(x), x)</code> as a return value for <code>transformer</code>&#39;s function. Instead you can use <a href="api/#StableHashTraits.TransformIdentity"><code>StableHashTraits.TransformIdentity</code></a> to make sure this won&#39;t lead to an infinite regress: e.g. <code>(mymetadata(x), TransformIdentity(x))</code>. Using <a href="api/#StableHashTraits.TransformIdentity"><code>StableHashTraits.TransformIdentity</code></a> will cause <code>x</code>&#39;s transformed result to be <code>x</code> itself, thereby avoiding the infinite regress.</p></div></div><p><code>transformer</code> customizes how the <em>content</em> of your object is hashed. The hash of the type is customized separately using <a href="api/#StableHashTraits.transform_type"><code>StableHashTraits.transform_type</code></a>.</p><h2 id="Using-Contexts"><a class="docs-heading-anchor" href="#Using-Contexts">Using Contexts</a><a id="Using-Contexts-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Contexts" title="Permalink"></a></h2><p>Because not every package knows about either <code>StableHashTraits</code> or <code>StructTypes</code>, there may be types you don&#39;t own that you want to customize the hash of. In this scenario you should define a context object that you pass as the second argument to <code>stable_hash</code> and define a method of <code>transformer</code> that dispatches on this context object as its second argument.</p><p>A context is simply an arbitrary object that defines a method for <a href="api/#StableHashTraits.parent_context"><code>StableHashTraits.parent_context</code></a>. By default the context to <code>stable_hash</code> is <code>HashVersion{version}()</code>. Because of <code>parent_context</code>, contexts can be stacked, and a <code>HashVersion</code> should be at the bottom of the stack. There are fallback methods for <code>transformer</code> that look at the value implemented by the parent context. In this way you need only define methods for the types you want to customize.</p><p>For example, this customization makes the ordering of named tuple keys affect the hash value.</p><pre><code class="language- hljs">julia&gt; begin
        struct NamedTuplesOrdered{T}
            parent::T
        end
        StableHashTraits.parent_context(x::NamedTuplesOrdered) = x.parent
        function transformer(::Type{&lt;:NamedTuple}, ::NamedTuplesOrdered)
            Transformer(identity, StructTypes.OrderedStruct())
        end
        context = NamedTuplesOrdered(HashVersion{4}())
       end;

julia&gt; stable_hash((; a=1:2, b=1:2), context) != stable_hash((; b=1:2, a=1:2), context)
true</code></pre><p>Without this context, the keys are first sorted because <code>StructType(NamedTuple) isa StructType.UnorderedStruct</code>.</p><p>As a short hand you can use <a href="api/#StableHashTraits.@context"><code>StableHashTraits.@context</code></a> for creating simple contexts, like the one above. Like so:</p><pre><code class="language-julia hljs">julia&gt; begin
        @context NamedTuplesOrdered
        function transformer(::Type{&lt;:NamedTuple}, ::NamedTuplesOrdered)
            Transformer(identity, StructTypes.OrderedStruct())
        end
        context = NamedTuplesOrdered(HashVersion{4}())
       end;

julia&gt; stable_hash((; a=1:2, b=1:2), context) != stable_hash((; b=1:2, a=1:2), context)
true</code></pre><p>There are several useful, predefined contexts available in <code>StableHashTraits</code> that can be used to change how hashing works:</p><ul><li><a href="api/#StableHashTraits.WithTypeNames"><code>WithTypeNames</code></a></li><li><a href="api/#StableHashTraits.TablesEq"><code>TablesEq</code></a></li></ul><h2 id="Optimizing-Custom-Transformers"><a class="docs-heading-anchor" href="#Optimizing-Custom-Transformers">Optimizing Custom Transformers</a><a id="Optimizing-Custom-Transformers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-Custom-Transformers" title="Permalink"></a></h2><p>By default, stable hash traits follows a safe, but slower code path for arbitrary functions passed to <code>Transformer</code>. However, in some cases it can use a faster code path, given that some assumptions about the types returned by the transforming function are maintained. The <code>identity</code> function and the functions returned by <a href="api/#StableHashTraits.pick_fields"><code>pick_fields</code></a> and <a href="api/#StableHashTraits.omit_fields"><code>omit_fields</code></a> use this faster code path by default.</p><p>In particular, a keyword argument to <code>Transformer</code>, <code>hoist_type</code> can be set to true to use this faster code path. Functions that implement <code>StableHashTraits.hoist_type(::typeof(fn))</code> can return <code>true</code> to signal that they are safe when using this faster code path. This function is called to determine the default value of <code>hoist_type</code> when this function is passed as the first argument to <code>Transformer</code>.</p><p>The exact criteria for when this code path is unsafe are somewhat subtle, and will be described below, along with some examples. However, you can always safely use <code>hoist_type=true</code> either when the function <em>always</em> returns the same type (e.g. it transforms all inputs into <code>String</code> values) OR when the following three criteria are met:</p><ol><li>The type that <code>transformer</code> dispatches on is concrete.</li><li>The type that <code>transformer</code> dispatches on contains no abstract types: that is, for any contained array type or dict types, their eltypes are concrete and for any contained data type, its <code>fieldtypes</code> are concrete.</li><li>The function you pass to <code>Transformer</code> is type stable</li></ol><p>When set to true, <code>hoist_type=true</code> hashes the type of the pre-transformed object, prior to looping over the contents of the post-transformed object: its fields (for a data type) or the elements (for an array or dict type). Once the contents of the object are being looped over, hashing the type of each concrete-typed element or field is skipped. For example, when hashing an <code>Array{Int}</code> the <code>Int</code> will only be hashed once, not once for every element.</p><p>When <code>hoist_type=false</code> (the default for most functions) the type of the return value from <code>transformer</code> is hashed alongside the transformed value. This can be a lot slower, but ensures the that no unexpected hash collisions will occur.</p><p>More precisely, this hoisting is only valid when one of these two criteria are satisfied:</p><ol><li>the pre-transformed type is sufficient to disambiguate the hash of the downstream object <em>values</em> absent their object <em>types</em>.</li><li>the post-transformed types do not change unless the <em>caller inferred</em> type of the input it depends on changes</li></ol><p>The latter criteria is more stringent than type stability. A function input could have a caller-inferred type of <code>Any</code>, be type stable, and return either <code>Char</code> or an <code>Int</code> depending on the value of its input. Such a function would violate this second criteria.</p><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><p>When is the pre-transformed type sufficient to disambiguate hashed values? First, many type-unstable functions should be considered unable to meet this criteria. The only time they are certain to be safe is when the values disambiguate the hash regardless of the type.</p><p>For instance, the assmuptions of <code>hoist_type=true</code> would be violated by the function <code>x -&gt; x &lt; 0 : Char(0) ? Int32(0)</code> because the bits that are hashed downstream are identical, even though the type information that should be hashed with them are different: <code>Char</code> is a <code>StringType</code> and <code>Ing32</code> is a <code>NumberType</code>.</p><p>In contrast, <code>x -&gt; x &lt; 0 : Char(1) : Int32(2)</code> is safe to use with <code>hoist_type=true</code>, because although the type changes, the byte sequence of the value never overlaps, regardless of the type returned. If you are confident the bit sequence will be unique in this way, you could safely use <code>hoist_type=true</code> even though the transformer is type unstable.</p><p>Beware! When a type unstable function will be unsafe for a given type depends on the context, because users can define their own <code>type_transform</code> that can lead to more type details being important to the hashed value. For instance, in the default context <code>x -&gt; x &lt; 0 : Int32(0) ? UInt32(0)</code> would be considered safe, since both <code>Int32</code> and <code>UInt32</code> have the same type for purposes of hashing (<code>NumberType</code>), <em>but</em> if the user were to write a custom <code>transform_type</code> in a <code>HashExactNumberType</code> context, now this function is no longer safe to use with <code>hoist_type=true</code>.</p><p>These examples hopefully help to clarify when type-unstable functions can lead to unexpected hash collisions with <code>hoist_type=true</code>. However type <em>stable</em> functions can also lead to invalid hashes with <code>hoist_type=true</code>. For example:</p><pre><code class="language-julia hljs">struct MyType
    a::Any
end
# ignore `metadata`, `data` will be hashed using fallbacks for `AbstractArray` type
# DO NOT DO IT THIS WAY; YOUR CODE WILL BE BUGGY!!!
StableHashTraits.transformer(::Type{&lt;:MyType}) = Transformer(x -&gt; (;x.a); hoist_type=true)
stable_hash(MyType(missing)) == stable_hash(MyType(nothing)) ## OOPS, we wanted these to be different but this returns `true`</code></pre><p>Setting the flag to <code>hoist_type=true</code> here causes the type of the <code>missing</code> and <code>nothing</code> to be hoisted, since the field <code>a</code> is a concrete type in the return value of <code>Transformer</code>&#39;s function. Since only the type of these two values is hashed, their hashes now collide. If the field of the pre-transformed type <code>a</code> was concrete, there wouldn&#39;t be any problem, because its type would be hashed, and that would include either the <code>Missing</code> or <code>Nothing</code> in the type hash.</p><p>For this reason, it is better to use <code>pick_fields</code> and <code>omit_fields</code> to select or remove fields from a type you want to transform.</p><pre><code class="language-julia hljs">struct MyType
    a::Any
end
StableHashTraits.transformer(::Type{&lt;:MyType}) = Transformer(x -&gt; (;x.a); hoist_type=false)
stable_hash(MyType(missing)) != stable_hash(MyType(nothing)) # true

# NOTE: pick_fields sets `hoist_type=true` by default; it is set here explicitly to
# clearly illustrate
# what is happening.
StableHashTraits.transformer(::Type{&lt;:MyType}) = Transformer(pick_fields(:a); hoist_type=true)
stable_hash(MyType(missing)) != stable_hash(MyType(nothing)) # this is also `true` and is faster than the previous implementation</code></pre><p>Bottom line: It is not sufficient for the function to be type stable to safely set <code>hoist_type=true</code>. If the return value of your transformer function over its known domain returns multiple distinct concrete types, you can run into problems.</p><h2 id="Customizing-Type-Hashes"><a class="docs-heading-anchor" href="#Customizing-Type-Hashes">Customizing Type Hashes</a><a id="Customizing-Type-Hashes-1"></a><a class="docs-heading-anchor-permalink" href="#Customizing-Type-Hashes" title="Permalink"></a></h2><p>Types are hashed by hashing the return value of <a href="api/#StableHashTraits.transform_type"><code>StableHashTraits.transform_type</code></a> when hashing an object&#39;s type and the return value of <a href="api/#StableHashTraits.transform_type_value"><code>StableHashTraits.transform_type_value</code></a> when hashing a type as a value (e.g. <code>stable_hash(Int)</code>). The docs for these functions provide several examples of their usage.</p><p>In addition there is some structure of the type that is always hashed:</p><ul><li><code>fieldtypes(T)</code> of any <code>StructType.DataType</code> (e.g. StructType.Struct)</li><li><code>eltype(T)</code> of any <code>StructType.ArrayType</code> or <code>StructType.DictType</code> or <code>AbstractRange</code></li></ul><p>These get added internally so as to ensure that the type-hoisting described above can rely on eltypes and fieldtypes storing all downstream children&#39;s concrete types.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 5 November 2024 03:14">Tuesday 5 November 2024</span>. Using Julia version 1.10.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
